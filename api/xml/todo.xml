<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="todo" kind="page">
    <compoundname>todo</compoundname>
    <title>Todo List</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><variablelist>
<varlistentry><term>Member <ref refid="classhelios_1_1app_1_1Application_1aec579824c0704542d3f7d6c4f47851a1" kindref="member">helios::app::Application::~Application</ref>  ()=default</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000003"/>free resource allocations from renderingDevice, window and InputManager  </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1event_1_1Event" kindref="compound">helios::event::Event</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000004"/>can we reset the value for Guids in between frames, if events are guaranteed to be dispatched and processed in between frames?  </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1ext_1_1glfw_1_1window_1_1GLFWWindow" kindref="compound">helios::ext::glfw::window::GLFWWindow</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000001"/>add glfwSetWindowRefreshCallback  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1ext_1_1opengl_1_1rendering_1_1OpenGLDevice_1aa97dd0a5a8fb57989616b7fac5139f8b" kindref="member">helios::ext::opengl::rendering::OpenGLDevice::init</ref>  () override</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000002"/>Provide abstraction for glfwGetProcAddress.  </para>
</listitem>
<varlistentry><term>Member <ref refid="structhelios_1_1math_1_1mat4_1a11484773381edf083309360d6c940d3f" kindref="member">helios::math::mat4&lt; T &gt;::same</ref>  (const mat4&lt; T &gt; &amp;rgt) const</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000005"/>account for abs (values close to zero) and rel (larger values), move EPSILON to global constant  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1rendering_1_1model_1_1Mesh_1abd79cc39a499bd1b368afd4dd534b00b" kindref="member">helios::rendering::model::Mesh::init</ref>  ()=0</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000006"/> std::shared_ptr&lt;const std::vector&lt;Texture&gt;&gt; textures_;  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1rendering_1_1RenderPassFactory_1a18d1346e8e3c78358ccb1872da3125a3" kindref="member">helios::rendering::RenderPassFactory::makeRenderCommand</ref>  (const <ref refid="structhelios_1_1scene_1_1SnapshotItem" kindref="compound">helios::scene::SnapshotItem</ref> &amp;snapshotItem) const noexcept</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000007"/>future versions might want to use a FactoryMethod in <ref refid="classhelios_1_1rendering_1_1RenderCommand" kindref="compound">RenderCommand</ref> that takes a SnapshotItem and creates a <ref refid="classhelios_1_1rendering_1_1RenderCommand" kindref="compound">RenderCommand</ref> from it (e.g. `RenderCommand::fromSnapshotItem()`); or a Factory `RenderCommandBuilder()` with fluent configuration `.withShader().withMesh().build();`  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1rendering_1_1RenderQueue_1ace107c45024c29efc237107e3307c2ab" kindref="member">helios::rendering::RenderQueue::add</ref>  (std::unique_ptr&lt; const helios::rendering::RenderCommand &gt; renderCommand)</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000008"/>prevent adding renderables while rendering  </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1rendering_1_1RenderTarget" kindref="compound">helios::rendering::RenderTarget</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000009"/>This implementation currently represents only the **default framebuffer**. Future extensions should allow it to represent arbitrary framebuffer objects (FBOs), using indices.  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1rendering_1_1RenderTarget_1a65cfc3bea57ac3b5eb398c85754dc049" kindref="member">helios::rendering::RenderTarget::setSize</ref>  (unsigned int width, unsigned int height) noexcept</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000011"/>A LayoutManager could be introduced to manage the arrangement of multiple viewports. </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1rendering_1_1shader_1_1UniformValueMap" kindref="compound">helios::rendering::shader::UniformValueMap</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000012"/>UniformMap must allow only one index for all data structures, i.e. if map_[semantics] contains a mat4f, other types should not be allowed for the same semantics.</para>
<para><anchor id="todo_1_todo000013"/>UniformValueMaps should be scoped, e.g. per frame (world matrix, projection, view...), per material (colors, emissive...), per object (world matrix...), which allows for better handling of assigning uniforms: per-frame values change once per frame, while per-object values change per object.  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1rendering_1_1Viewport_1a9c8ed040c0e35728770ddd462860c5bc" kindref="member">helios::rendering::Viewport::setRenderTarget</ref>  (const <ref refid="classhelios_1_1rendering_1_1RenderTarget" kindref="compound">helios::rendering::RenderTarget</ref> *renderTarget, <ref refid="structhelios_1_1rendering_1_1ViewportKey" kindref="compound">ViewportKey</ref> key) noexcept</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000014"/>The <ref refid="classhelios_1_1rendering_1_1Viewport" kindref="compound">Viewport</ref> should observe the <ref refid="classhelios_1_1rendering_1_1RenderTarget" kindref="compound">RenderTarget</ref> for state changes (e.g., resize).  </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1scene_1_1Camera" kindref="compound">helios::scene::Camera</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000015"/>Implement automatic recalculation of projection and view matrices when local transforms change (dirty flag pattern).  </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1scene_1_1CameraSceneNode" kindref="compound">helios::scene::CameraSceneNode</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000016"/>Check whether nodes should further be divided into ParentNode and LeafNode types. Cameras would be LeafNodes, not allowing child nodes.  </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1scene_1_1FrustumCullingStrategy" kindref="compound">helios::scene::FrustumCullingStrategy</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000018"/>The returned list should be considered &quot;as is&quot; for now: Each entry in the list is a single renderable entity to consider. Its child nodes (i.e. the sub tree for which this node is the root) should _not_ be automatically considered for rendering. Later iterations should probably use an individual struct that provides a hint whether for a given node a whole subtree should be considered, saving time for culling and memory when constructing the list.  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1scene_1_1Scene_1ab3ad742392c2a2b159cf8927ee6cf375" kindref="member">helios::scene::Scene::createSnapshot</ref>  (const std::shared_ptr&lt; const rendering::Viewport &gt; &amp;viewport) const</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000020"/>This should be refactored into a factory to prevent domain leakage between <ref refid="classhelios_1_1scene_1_1Scene" kindref="compound">Scene</ref> and Rendering.  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1scene_1_1SceneNode_1a316494fedf68d4ca53cd4453885e0b07" kindref="member">helios::scene::SceneNode::SceneNode</ref>  () noexcept</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000021"/>explicitly implement move (assignment) constructor if required, since we have deleted the copy constructors  </para>
</listitem>
<varlistentry><term>Struct <ref refid="structhelios_1_1scene_1_1SnapshotItem" kindref="compound">helios::scene::SnapshotItem</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000022"/>we&apos;re intentionally preferring stability over performance by using weak_ptr instead of raw pointers. This leaves room for (performance) improvements in later iterations. The Renderable as a weak pointer can later on be further implemented into a pure DTO, storing only scalar values that get send directly to the underlying rendering backend (e.g. vaos, vbos etc.).  </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1scene_1_1Transform" kindref="compound">helios::scene::Transform</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000023"/>use quaternions for rotation  </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1util_1_1log_1_1Logger" kindref="compound">helios::util::log::Logger</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000024"/>configure log stream, severity filtering and thread-safety. </para>
</listitem>
</variablelist>
</para>
    </detaileddescription>
    <location file="todo"/>
  </compounddef>
</doxygen>
