<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="todo" kind="page">
    <compoundname>todo</compoundname>
    <title>Todo List</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><variablelist>
<varlistentry><term>Member <ref refid="classhelios_1_1app_1_1Application_1aec579824c0704542d3f7d6c4f47851a1" kindref="member">helios::app::Application::~Application</ref>  ()=default</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000006"/>free resource allocations from renderingDevice, window and InputManager  </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1core_1_1spatial_1_1Transform" kindref="compound">helios::core::spatial::Transform</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000007"/>use quaternions for rotation  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1engine_1_1builder_1_1gameObject_1_1GameObjectFactory_1a397b02576652662326a68bf15612309a" kindref="member">helios::engine::builder::gameObject::GameObjectFactory::from</ref>  (<ref refid="classhelios_1_1engine_1_1ecs_1_1GameObject" kindref="compound">helios::engine::ecs::GameObject</ref> *gameObject)</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000008"/>Optional ClonePolicy where rules are specified?  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1engine_1_1mechanics_1_1bounds_1_1systems_1_1LevelBoundsBehaviorSystem_1ac1e97cde1b5f98aaec15989da6e864ab" kindref="member">helios::engine::mechanics::bounds::systems::LevelBoundsBehaviorSystem::update</ref>  (<ref refid="structhelios_1_1engine_1_1runtime_1_1world_1_1UpdateContext" kindref="compound">helios::engine::runtime::world::UpdateContext</ref> &amp;updateContext) noexcept override</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000009"/>optimize  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1engine_1_1mechanics_1_1input_1_1systems_1_1TwinStickInputSystem_1acca47c4456273d89230d78679270eef9" kindref="member">helios::engine::mechanics::input::systems::TwinStickInputSystem::update</ref>  (<ref refid="structhelios_1_1engine_1_1runtime_1_1world_1_1UpdateContext" kindref="compound">helios::engine::runtime::world::UpdateContext</ref> &amp;updateContext) noexcept override</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000010"/>DO NOT POST IF input is already inactive in shootComponent and no input was detected (after normalizing)  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1engine_1_1mechanics_1_1spawn_1_1systems_1_1GameObjectSpawnSystem_1a69d47de2e4bae743dab2fc03349b3902" kindref="member">helios::engine::mechanics::spawn::systems::GameObjectSpawnSystem::update</ref>  (<ref refid="structhelios_1_1engine_1_1runtime_1_1world_1_1UpdateContext" kindref="compound">helios::engine::runtime::world::UpdateContext</ref> &amp;updateContext) noexcept override</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000011"/>this should be processed before iterating over all schedulers: A scheduler owns the rule, hence a rule that triggered the event&apos;s can be associated with the owning Scheduler, making it unneccesary to iterate over already processed events  </para>
</listitem>
<varlistentry><term>Namespace <ref refid="namespacehelios_1_1engine_1_1modules_1_1effects_1_1gfx_1_1components" kindref="compound">helios::engine::modules::effects::gfx::components</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000012"/>move to spatial or effects  </para>
</listitem>
<varlistentry><term>Namespace <ref refid="namespacehelios_1_1engine_1_1modules_1_1spatial_1_1transform_1_1components" kindref="compound">helios::engine::modules::spatial::transform::components</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000014"/>move to spatial transform  </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1engine_1_1runtime_1_1pooling_1_1GameObjectPool" kindref="compound">helios::engine::runtime::pooling::GameObjectPool</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000015"/>Prevent duplicate Guids from being added to the pool.  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1engine_1_1runtime_1_1world_1_1GameWorld_1a6901bdce0c643c7586dc14697e498b7d" kindref="member">helios::engine::runtime::world::GameWorld::clone</ref>  (const <ref refid="classhelios_1_1engine_1_1ecs_1_1GameObject" kindref="compound">helios::engine::ecs::GameObject</ref> &amp;gameObject)</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000017"/>Optional ClonePolicy where rules are specified?  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1engine_1_1tooling_1_1FramePacer_1ac6b55e3ef2b685222358c14e69e89f06" kindref="member">helios::engine::tooling::FramePacer::sync</ref>  ()</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000018"/>Implement hybrid spinning for the last millisecond of the wait time to improve timing precision and mitigate OS scheduler wake-up latency.  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1event_1_1BasicEventManager_1a572c4c66409151b16992008849d9bbe6" kindref="member">helios::event::BasicEventManager::post</ref>  (std::unique_ptr&lt; const Event &gt; event, <ref refid="namespacehelios_1_1event_1a68d7042f97d91ed8414724453213e7f0" kindref="member">PostPolicy</ref> policy, const std::function&lt; bool(const std::unique_ptr&lt; const Event &gt; &amp;event, const std::unique_ptr&lt; const Event &gt; &amp;evt)&gt; &amp;func) override</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000019"/>use hashmap instead of queue for faster lookup  </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1event_1_1Event" kindref="compound">helios::event::Event</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000020"/>can we reset the value for Guids in between frames, if events are guaranteed to be dispatched and processed in between frames?  </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1ext_1_1glfw_1_1window_1_1GLFWWindow" kindref="compound">helios::ext::glfw::window::GLFWWindow</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000001"/>add glfwSetWindowRefreshCallback  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1ext_1_1opengl_1_1rendering_1_1model_1_1OpenGLMesh_1a77951b4083715c1e2bbbdea305b16b57" kindref="member">helios::ext::opengl::rendering::model::OpenGLMesh::OpenGLMesh</ref>  (std::shared_ptr&lt; const std::vector&lt; helios::rendering::Vertex &gt; &gt; vertices, std::shared_ptr&lt; const std::vector&lt; unsigned int &gt; &gt; indices, std::shared_ptr&lt; const helios::rendering::mesh::MeshConfig &gt; meshConfig)</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000002"/>this should not be part of the constructor, instead, lazy init in render pass, then reuse.  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1ext_1_1opengl_1_1rendering_1_1model_1_1OpenGLMesh_1a878fbf33ad6e8e67ded9b9e1bf2f3eb9" kindref="member">helios::ext::opengl::rendering::model::OpenGLMesh::OpenGLMesh</ref>  (const <ref refid="structhelios_1_1rendering_1_1asset_1_1shape_1_1Shape" kindref="compound">helios::rendering::asset::shape::Shape</ref> &amp;shape, std::shared_ptr&lt; const helios::rendering::mesh::MeshConfig &gt; meshConfig)</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000003"/>this should not be part of the constructor, instead, lazy init in render pass, then reuse.  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1ext_1_1opengl_1_1rendering_1_1OpenGLDevice_1aa97dd0a5a8fb57989616b7fac5139f8b" kindref="member">helios::ext::opengl::rendering::OpenGLDevice::init</ref>  () override</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000004"/>Provide abstraction for glfwGetProcAddress.  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1ext_1_1opengl_1_1rendering_1_1OpenGLGlyphTextRenderer_1a1a00f69a4c65901d576d00ac8fd135e8" kindref="member">helios::ext::opengl::rendering::OpenGLGlyphTextRenderer::~OpenGLGlyphTextRenderer</ref>  () override</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000005"/>glDeleteTextures()  </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1input_1_1InputSnapshot" kindref="compound">helios::input::InputSnapshot</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000021"/>Extend to support multiple gamepads, keyboard, and mouse input. </para>
<para></para>
<para>Add timestamp to enable precise replay and network synchronization.  </para>
</listitem>
<varlistentry><term>Member <ref refid="structhelios_1_1math_1_1mat4_1a11484773381edf083309360d6c940d3f" kindref="member">helios::math::mat4&lt; T &gt;::same</ref>  (const mat4&lt; T &gt; &amp;rgt) const</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000022"/>account for abs (values close to zero) and rel (larger values), move EPSILON to global constant  </para>
</listitem>
<varlistentry><term>Member <ref refid="structhelios_1_1math_1_1vec2_1a14a40e171d65f8df56deab0b80a6c800" kindref="member">helios::math::vec2&lt; T &gt;::same</ref>  (const vec2&lt; T &gt; &amp;rgt, T epsilon=0.0001) const</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000023"/>account for abs (values close to zero) and rel (larger values), move epsilon to global constant?  </para>
</listitem>
<varlistentry><term>Member <ref refid="structhelios_1_1math_1_1vec3_1a38d076eec3ebd34f4353d99e3f58ad1e" kindref="member">helios::math::vec3&lt; T &gt;::same</ref>  (const vec3&lt; T &gt; &amp;rgt, T epsilon=0.0001) const</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000024"/>account for abs (values close to zero) and rel (larger values), move epsilon to global constant?  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1rendering_1_1mesh_1_1Mesh_1af94de770b332752e3b7fb1d6bad446d9" kindref="member">helios::rendering::mesh::Mesh::init</ref>  ()=0</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000025"/> std::shared_ptr&lt;const std::vector&lt;Texture&gt;&gt; textures_;  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1rendering_1_1RenderQueue_1a8cd37510ae60116863bea9d3bafe2254" kindref="member">helios::rendering::RenderQueue::add</ref>  (<ref refid="classhelios_1_1rendering_1_1mesh_1_1MeshRenderCommand" kindref="compound">helios::rendering::mesh::MeshRenderCommand</ref> renderCommand)</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000026"/>prevent adding renderables while rendering  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1rendering_1_1RenderQueue_1a2d14f75f8f57728f71608dbfde485d80" kindref="member">helios::rendering::RenderQueue::clear</ref>  ()</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000027"/>strategy to decide whether shrink_to_fit should only be applied if expected numbers RenderCommands for the subsequent render passes is less than current size?  </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1rendering_1_1RenderTarget" kindref="compound">helios::rendering::RenderTarget</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000028"/>This implementation currently represents only the **default framebuffer**. Future extensions should allow it to represent arbitrary framebuffer objects (FBOs), using indices.  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1rendering_1_1RenderTarget_1a65cfc3bea57ac3b5eb398c85754dc049" kindref="member">helios::rendering::RenderTarget::setSize</ref>  (unsigned int width, unsigned int height) noexcept</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000030"/>A LayoutManager could be introduced to manage the arrangement of multiple viewports. </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1rendering_1_1shader_1_1UniformValueMap" kindref="compound">helios::rendering::shader::UniformValueMap</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000031"/>UniformMap must allow only one index for all data structures, i.e. if map_[semantics] contains a mat4f, other types should not be allowed for the same semantics.</para>
<para><anchor id="todo_1_todo000032"/>UniformValueMaps should be scoped, e.g. per frame (world matrix, projection, view...), per material (colors, emissive...), per object (world matrix...), which allows for better handling of assigning uniforms: per-frame values change once per frame, while per-object values change per object.  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1rendering_1_1Viewport_1a9c8ed040c0e35728770ddd462860c5bc" kindref="member">helios::rendering::Viewport::setRenderTarget</ref>  (const <ref refid="classhelios_1_1rendering_1_1RenderTarget" kindref="compound">helios::rendering::RenderTarget</ref> *renderTarget, <ref refid="structhelios_1_1rendering_1_1ViewportKey" kindref="compound">ViewportKey</ref> key) noexcept</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000033"/>The <ref refid="classhelios_1_1rendering_1_1Viewport" kindref="compound">Viewport</ref> should observe the <ref refid="classhelios_1_1rendering_1_1RenderTarget" kindref="compound">RenderTarget</ref> for state changes (e.g., resize).  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1scene_1_1CameraSceneNode_1ad57acd6f8c8b2e6b02707ba1424377cb" kindref="member">helios::scene::CameraSceneNode::lookAt</ref>  (<ref refid="namespacehelios_1_1math_1a71f1e40e636f47229c3122bdb63099d5" kindref="member">helios::math::vec3f</ref> target, <ref refid="namespacehelios_1_1math_1a71f1e40e636f47229c3122bdb63099d5" kindref="member">helios::math::vec3f</ref> up)</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000034"/>add support for different rotations  </para>
</listitem>
<varlistentry><term>Class <ref refid="classhelios_1_1scene_1_1FrustumCullingStrategy" kindref="compound">helios::scene::FrustumCullingStrategy</ref>  </term></varlistentry>
<listitem><para><anchor id="todo_1_todo000035"/>The returned list should be considered &quot;as is&quot; for now: Each entry in the list is a single renderable entity to consider. Its child nodes (i.e. the sub tree for which this node is the root) should _not_ be automatically considered for rendering. Later iterations should probably use an individual struct that provides a hint whether for a given node a whole subtree should be considered, saving time for culling and memory when constructing the list.  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1scene_1_1Scene_1a054843594de8ccc99336935ac0cbde11" kindref="member">helios::scene::Scene::createSnapshot</ref>  (const <ref refid="classhelios_1_1rendering_1_1Viewport" kindref="compound">rendering::Viewport</ref> &amp;viewport) const</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000037"/>This should be refactored into a factory to prevent domain leakage between <ref refid="classhelios_1_1scene_1_1Scene" kindref="compound">Scene</ref> and Rendering.  </para>
</listitem>
<varlistentry><term>Member <ref refid="classhelios_1_1scene_1_1SceneNode_1a316494fedf68d4ca53cd4453885e0b07" kindref="member">helios::scene::SceneNode::SceneNode</ref>  () noexcept</term></varlistentry>
<listitem><para><anchor id="todo_1_todo000038"/>explicitly implement move (assignment) constructor if required, since we have deleted the copy constructors </para>
</listitem>
</variablelist>
</para>
    </detaileddescription>
    <location file="todo"/>
  </compounddef>
</doxygen>
