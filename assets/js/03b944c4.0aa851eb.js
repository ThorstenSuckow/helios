"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[19058],{13205:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"core-concepts/ecs/component-structure","title":"Component Structure","description":"Required structure for ECS components including Copy/Move constructors for the prefab system.","source":"@site/docs/core-concepts/ecs/component-structure.md","sourceDirName":"core-concepts/ecs","slug":"/core-concepts/ecs/component-structure","permalink":"/docs/core-concepts/ecs/component-structure","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/ecs/component-structure.md","tags":[{"inline":true,"label":"ecs","permalink":"/docs/tags/ecs"},{"inline":true,"label":"component","permalink":"/docs/tags/component"},{"inline":true,"label":"prefab","permalink":"/docs/tags/prefab"}],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Component Structure","description":"Required structure for ECS components including Copy/Move constructors for the prefab system.","slug":"/core-concepts/ecs/component-structure","sidebar_label":"Component Structure","sidebar_position":1,"tags":["ecs","component","prefab"],"keywords":["helios","component","copy constructor","move constructor","prefab","cloning"]},"sidebar":"tutorialSidebar","previous":{"title":"Overview","permalink":"/docs/core-concepts/ecs"},"next":{"title":"GameObject","permalink":"/docs/core-concepts/ecs/gameobject"}}');var c=o(74848),s=o(28453);const r={title:"Component Structure",description:"Required structure for ECS components including Copy/Move constructors for the prefab system.",slug:"/core-concepts/ecs/component-structure",sidebar_label:"Component Structure",sidebar_position:1,tags:["ecs","component","prefab"],keywords:["helios","component","copy constructor","move constructor","prefab","cloning"]},i="Component Structure",l={},a=[{value:"Overview",id:"overview",level:2},{value:"Basic Component Structure",id:"basic-component-structure",level:2},{value:"Why Copy/Move Constructors Are Required",id:"why-copymove-constructors-are-required",level:2},{value:"The Prefab System",id:"the-prefab-system",level:3},{value:"Copy Constructor Requirements",id:"copy-constructor-requirements",level:3},{value:"Move Constructor Requirements",id:"move-constructor-requirements",level:3},{value:"Complete Component Example",id:"complete-component-example",level:2},{value:"Copy Constructor Patterns",id:"copy-constructor-patterns",level:2},{value:"Pattern 1: Copy Configuration Only",id:"pattern-1-copy-configuration-only",level:3},{value:"Pattern 2: Full Copy with onClone Hook",id:"pattern-2-full-copy-with-onclone-hook",level:3},{value:"Pattern 3: Non-Copyable with Clone Fallback",id:"pattern-3-non-copyable-with-clone-fallback",level:3},{value:"Registration",id:"registration",level:2},{value:"Checklist",id:"checklist",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"component-structure",children:"Component Structure"})}),"\n",(0,c.jsxs)(n.p,{children:["This document describes the required structure for components in the helios ECS, including the ",(0,c.jsx)(n.strong,{children:"mandatory Copy/Move constructors"})," needed for the prefab/cloning system."]}),"\n",(0,c.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,c.jsxs)(n.p,{children:["Components in helios are ",(0,c.jsx)(n.strong,{children:"plain data classes"})," (POD-like) without inheritance from a base class. The ECS uses ",(0,c.jsx)(n.strong,{children:"compile-time trait detection"})," to discover lifecycle hooks, enabling zero-overhead optional functionality."]}),"\n",(0,c.jsx)(n.h2,{id:"basic-component-structure",children:"Basic Component Structure"}),"\n",(0,c.jsx)(n.p,{children:"Every component should follow this structure:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-cpp",children:"class MyComponent {\nprivate:\n    // Data members\n    float value_;\n    bool isEnabled_ = true;\n\npublic:\n    // 1. Default constructor\n    MyComponent() = default;\n\n    // 2. Copy constructor (REQUIRED for cloning)\n    MyComponent(const MyComponent& other);\n\n    // 3. Copy assignment operator\n    MyComponent& operator=(const MyComponent&) = default;\n\n    // 4. Move constructor (REQUIRED, must be noexcept)\n    MyComponent(MyComponent&&) noexcept = default;\n\n    // 5. Move assignment operator\n    MyComponent& operator=(MyComponent&&) noexcept = default;\n\n    // 6. Enable/Disable (optional, for view filtering)\n    [[nodiscard]] bool isEnabled() const noexcept { return isEnabled_; }\n    void enable() noexcept { isEnabled_ = true; }\n    void disable() noexcept { isEnabled_ = false; }\n\n    // 7. Lifecycle hooks (optional)\n    void onAcquire() noexcept;\n    void onRelease() noexcept;\n};\n"})}),"\n",(0,c.jsx)(n.h2,{id:"why-copymove-constructors-are-required",children:"Why Copy/Move Constructors Are Required"}),"\n",(0,c.jsx)(n.h3,{id:"the-prefab-system",children:"The Prefab System"}),"\n",(0,c.jsxs)(n.p,{children:["helios uses a ",(0,c.jsx)(n.strong,{children:"prefab-based spawning system"})," where template GameObjects (prefabs) are cloned to create new instances:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      clone()      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Prefab      \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502   New Entity    \u2502\n\u2502  (Template)     \u2502                   \u2502   (Instance)    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 HealthComponent \u2502 \u2500\u2500\u2500\u2500 copy \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502 HealthComponent \u2502\n\u2502 MoveComponent   \u2502 \u2500\u2500\u2500\u2500 copy \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502 MoveComponent   \u2502\n\u2502 RenderComponent \u2502 \u2500\u2500\u2500\u2500 copy \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502 RenderComponent \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,c.jsxs)(n.p,{children:["When ",(0,c.jsx)(n.code,{children:"GameWorld::clone()"})," or ",(0,c.jsx)(n.code,{children:"GameObjectPoolManager::acquire()"})," is called, ",(0,c.jsx)(n.strong,{children:"all components are copied"})," from the prefab to the new entity using their copy constructors."]}),"\n",(0,c.jsx)(n.h3,{id:"copy-constructor-requirements",children:"Copy Constructor Requirements"}),"\n",(0,c.jsxs)(n.p,{children:["The copy constructor is invoked by ",(0,c.jsx)(n.code,{children:"ComponentReflector"})," during cloning:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-cpp",children:"// In ComponentReflector::registerType<T>()\n.clone = [](void* managerRaw, const void* sourceRaw, const EntityHandle* target) -> void* {\n    auto* manager = static_cast<EntityManager*>(managerRaw);\n    const auto* source = static_cast<const T*>(sourceRaw);\n\n    // Copy constructor is called here!\n    T* cmp = manager->emplace<T>(*target, *source);\n\n    // onClone() hook called after copy\n    if constexpr (traits::HasClone<T>) {\n        cmp->onClone(*source);\n    }\n\n    return cmp;\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"If your component is not copy-constructible, cloning will fail silently"})," (returns ",(0,c.jsx)(n.code,{children:"nullptr"}),")."]}),"\n",(0,c.jsx)(n.h3,{id:"move-constructor-requirements",children:"Move Constructor Requirements"}),"\n",(0,c.jsxs)(n.p,{children:["The move constructor ",(0,c.jsxs)(n.strong,{children:["must be ",(0,c.jsx)(n.code,{children:"noexcept"})]})," due to how ",(0,c.jsx)(n.code,{children:"std::vector"})," works internally."]}),"\n",(0,c.jsxs)(n.p,{children:["Components are stored in ",(0,c.jsx)(n.code,{children:"SparseSet<T>"}),", which uses ",(0,c.jsx)(n.code,{children:"std::vector<T>"})," as its dense storage:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-cpp",children:"// In SparseSet<T>\nstd::vector<T> storage_;\n"})}),"\n",(0,c.jsxs)(n.p,{children:["When the vector reallocates (grows), it must move existing elements to new memory. ",(0,c.jsx)(n.code,{children:"std::vector"})," uses:"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Move constructor"})," if it's ",(0,c.jsx)(n.code,{children:"noexcept"})]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Copy constructor"})," if move is not ",(0,c.jsx)(n.code,{children:"noexcept"})," (for strong exception guarantee)"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Problem:"})," If your move constructor is not ",(0,c.jsx)(n.code,{children:"noexcept"}),", the copy constructor is called during reallocation, which can cause:"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Unexpected side effects (e.g., creating duplicate SceneNodes)"}),"\n",(0,c.jsx)(n.li,{children:"Performance degradation (copying instead of moving)"}),"\n",(0,c.jsx)(n.li,{children:"Subtle bugs that only appear when the vector grows"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-cpp",children:"// BAD: Copy constructor called on vector reallocation!\nclass BadComponent {\n    BadComponent(BadComponent&&) { }  // Not noexcept!\n};\n\n// GOOD: Move constructor is noexcept\nclass GoodComponent {\n    GoodComponent(GoodComponent&&) noexcept = default;\n};\n"})}),"\n",(0,c.jsx)(n.h2,{id:"complete-component-example",children:"Complete Component Example"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-cpp",children:"/**\n * @brief Component for tracking entity health.\n */\nclass HealthComponent {\nprivate:\n    float maxHealth_{100.0f};\n    float health_{0.0f};\n    bool isEnabled_ = true;\n\npublic:\n    // Default constructor\n    HealthComponent() = default;\n\n    // Parameterized constructor\n    explicit HealthComponent(float maxHealth) : maxHealth_(maxHealth) {}\n\n    // Copy constructor - copies configuration, not runtime state\n    HealthComponent(const HealthComponent& other)\n        : maxHealth_(other.maxHealth_)\n        , isEnabled_(other.isEnabled_) {\n        // Note: health_ is NOT copied - it's reset in onAcquire()\n    }\n\n    // Copy assignment\n    HealthComponent& operator=(const HealthComponent&) = default;\n\n    // Move constructor - MUST be noexcept\n    HealthComponent(HealthComponent&&) noexcept = default;\n\n    // Move assignment\n    HealthComponent& operator=(HealthComponent&&) noexcept = default;\n\n    // Enable/Disable for view filtering\n    [[nodiscard]] bool isEnabled() const noexcept { return isEnabled_; }\n    void enable() noexcept { isEnabled_ = true; }\n    void disable() noexcept { isEnabled_ = false; }\n\n    // Pool lifecycle hooks\n    void onAcquire() noexcept {\n        health_ = maxHealth_;  // Reset on spawn\n    }\n\n    void onRelease() noexcept {\n        health_ = maxHealth_;  // Reset on despawn\n    }\n\n    // Getters/Setters\n    [[nodiscard]] float health() const noexcept { return health_; }\n    [[nodiscard]] float maxHealth() const noexcept { return maxHealth_; }\n    [[nodiscard]] bool isAlive() const noexcept { return health_ > 0.0f; }\n\n    void takeDamage(float damage) noexcept {\n        health_ = std::max(0.0f, health_ - damage);\n    }\n};\n"})}),"\n",(0,c.jsx)(n.h2,{id:"copy-constructor-patterns",children:"Copy Constructor Patterns"}),"\n",(0,c.jsx)(n.h3,{id:"pattern-1-copy-configuration-only",children:"Pattern 1: Copy Configuration Only"}),"\n",(0,c.jsx)(n.p,{children:"For components with runtime state that should be reset on clone:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-cpp",children:"class TimerComponent {\n    float duration_;      // Configuration - copy this\n    float elapsed_{0.0f}; // Runtime state - don't copy\n\npublic:\n    TimerComponent(const TimerComponent& other)\n        : duration_(other.duration_) {\n        // elapsed_ starts at 0 for clones\n    }\n};\n"})}),"\n",(0,c.jsx)(n.h3,{id:"pattern-2-full-copy-with-onclone-hook",children:"Pattern 2: Full Copy with onClone Hook"}),"\n",(0,c.jsx)(n.p,{children:"For components that need post-copy initialization:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-cpp",children:"class SceneNodeComponent {\n    SceneNode* sceneNode_;\n\npublic:\n    // Copy constructor - just copy the pointer (temporary)\n    SceneNodeComponent(const SceneNodeComponent& other) = default;\n\n    // onClone - create a NEW SceneNode for this entity\n    void onClone(const SceneNodeComponent& source) {\n        auto* parent = source.sceneNode_->parent();\n        auto node = std::make_unique<SceneNode>(\n            source.sceneNode_->shareRenderable()\n        );\n        sceneNode_ = parent->addNode(std::move(node));\n    }\n};\n"})}),"\n",(0,c.jsx)(n.h3,{id:"pattern-3-non-copyable-with-clone-fallback",children:"Pattern 3: Non-Copyable with Clone Fallback"}),"\n",(0,c.jsx)(n.p,{children:"For components that manage unique resources:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-cpp",children:"class UniqueResourceComponent {\n    std::unique_ptr<Resource> resource_;\n\npublic:\n    // Explicitly deleted - cannot be cloned\n    UniqueResourceComponent(const UniqueResourceComponent&) = delete;\n\n    // Move is fine\n    UniqueResourceComponent(UniqueResourceComponent&&) noexcept = default;\n};\n"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Note:"})," Non-copyable components cannot participate in prefab cloning. The ",(0,c.jsx)(n.code,{children:"ComponentReflector"})," will skip them during clone operations."]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"registration",children:"Registration"}),"\n",(0,c.jsxs)(n.p,{children:["Components must be registered with the ",(0,c.jsx)(n.code,{children:"ComponentReflector"})," before use:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-cpp",children:"// In module registry (e.g., helios/engine/mechanics/health/registry.ixx)\ninline void registerComponents() {\n    using R = helios::engine::ecs::ComponentReflector;\n    R::registerType<HealthComponent>();\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["Registration generates ",(0,c.jsx)(n.code,{children:"ComponentOps"})," function pointers for all detected lifecycle hooks."]}),"\n",(0,c.jsx)(n.h2,{id:"checklist",children:"Checklist"}),"\n",(0,c.jsx)(n.p,{children:"When creating a new component, verify:"}),"\n",(0,c.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,c.jsxs)(n.li,{className:"task-list-item",children:[(0,c.jsx)(n.input,{type:"checkbox",disabled:!0})," Default constructor exists"]}),"\n",(0,c.jsxs)(n.li,{className:"task-list-item",children:[(0,c.jsx)(n.input,{type:"checkbox",disabled:!0})," Copy constructor is implemented (or explicitly ",(0,c.jsx)(n.code,{children:"= default"}),")"]}),"\n",(0,c.jsxs)(n.li,{className:"task-list-item",children:[(0,c.jsx)(n.input,{type:"checkbox",disabled:!0})," Move constructor is ",(0,c.jsx)(n.code,{children:"noexcept"})," (or ",(0,c.jsx)(n.code,{children:"= default"}),")"]}),"\n",(0,c.jsxs)(n.li,{className:"task-list-item",children:[(0,c.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,c.jsx)(n.code,{children:"isEnabled()"})," / ",(0,c.jsx)(n.code,{children:"enable()"})," / ",(0,c.jsx)(n.code,{children:"disable()"})," are implemented (if view filtering is needed)"]}),"\n",(0,c.jsxs)(n.li,{className:"task-list-item",children:[(0,c.jsx)(n.input,{type:"checkbox",disabled:!0})," Lifecycle hooks (",(0,c.jsx)(n.code,{children:"onAcquire"}),", ",(0,c.jsx)(n.code,{children:"onRelease"}),", etc.) are implemented as needed"]}),"\n",(0,c.jsxs)(n.li,{className:"task-list-item",children:[(0,c.jsx)(n.input,{type:"checkbox",disabled:!0})," Component is registered with ",(0,c.jsx)(n.code,{children:"ComponentReflector"})]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.a,{href:"/docs/core-concepts/component-lifecycle",children:"Component Lifecycle"})," - Lifecycle hooks in detail"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.a,{href:"/docs/core-concepts/ecs/traits",children:"Traits"})," - Compile-time hook detection"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.a,{href:"/docs/core-concepts/ecs/component-ops",children:"ComponentOps"})," - Function pointer storage"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.a,{href:"/docs/core-concepts/spawn-system",children:"Spawn System"})," - Prefab and pooling details"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}},28453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>i});var t=o(96540);const c={},s=t.createContext(c);function r(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);