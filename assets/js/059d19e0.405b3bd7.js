"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[63560],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var s=t(96540);const a={},o=s.createContext(a);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(o.Provider,{value:n},e.children)}},35214:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>l,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"core-concepts/gameloop-architecture","title":"Game Loop Architecture","description":"Commands, Events, double-buffered EventBus, and ImmediateBus for decoupled game systems.","source":"@site/docs/core-concepts/gameloop-architecture.md","sourceDirName":"core-concepts","slug":"/core-concepts/gameloop-architecture","permalink":"/docs/core-concepts/gameloop-architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/gameloop-architecture.md","tags":[{"inline":true,"label":"gameplay","permalink":"/docs/tags/gameplay"},{"inline":true,"label":"architecture","permalink":"/docs/tags/architecture"}],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Game Loop Architecture","description":"Commands, Events, double-buffered EventBus, and ImmediateBus for decoupled game systems.","slug":"/core-concepts/gameloop-architecture","sidebar_label":"Game Loop","sidebar_position":4,"tags":["gameplay","architecture"],"keywords":["helios","game loop","commands","events","EventBus","CommandBuffer"]},"sidebar":"tutorialSidebar","previous":{"title":"Component System","permalink":"/docs/core-concepts/component-system"},"next":{"title":"Overview","permalink":"/docs/examples"}}');var a=t(74848),o=t(28453);const r={title:"Game Loop Architecture",description:"Commands, Events, double-buffered EventBus, and ImmediateBus for decoupled game systems.",slug:"/core-concepts/gameloop-architecture",sidebar_label:"Game Loop",sidebar_position:4,tags:["gameplay","architecture"],keywords:["helios","game loop","commands","events","EventBus","CommandBuffer"]},i="Game Loop Architecture",d={},c=[{value:"Commands and CommandBuffer",id:"commands-and-commandbuffer",level:2},{value:"Events and double-buffered EventBus",id:"events-and-double-buffered-eventbus",level:2},{value:"Optional manager-based command processing",id:"optional-manager-based-command-processing",level:3},{value:"Immediate Events (single-buffered)",id:"immediate-events-single-buffered",level:2},{value:"Frame Order Summary",id:"frame-order-summary",level:2}];function m(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"game-loop-architecture",children:"Game Loop Architecture"})}),"\n",(0,a.jsxs)(n.p,{children:["helios distinguishes between ",(0,a.jsx)(n.strong,{children:"Commands"})," (world-mutating operations) and ",(0,a.jsx)(n.strong,{children:"Events"})," (signals/facts).\nCommands exist to mutate the world state ",(0,a.jsx)(n.em,{children:"deterministically"}),". Events exist to decouple systems: they either express a request/intent (e.g. SpawnRequest) or a fact (e.g. ",(0,a.jsx)(n.code,{children:"SolidCollisionEvent"}),", ",(0,a.jsx)(n.code,{children:"TriggerCollisionEvent"}),", ",(0,a.jsx)(n.code,{children:"SpawnedEvent"}),")."]}),"\n",(0,a.jsx)(n.h2,{id:"commands-and-commandbuffer",children:"Commands and CommandBuffer"}),"\n",(0,a.jsxs)(n.p,{children:["Participating systems can write Commands into the CommandBuffer in frame N.\nAt the beginning of each frame N+1, the CommandBuffer is flushed, which commits the Commands - i.e. their ",(0,a.jsx)(n.code,{children:"execute()"}),' method is invoked. This method contains the logic that mutates the world state (e.g. spawning, despawning, health changes, component changes). Commands are "bare metal" and therefore the lowest level in the game-loop layer, i.e. no further preparation of a Command is required. The system should therefore also be able to commit Commands coming directly from a developer console into the GameWorld (optionally delegating them to their respective managers - see below).']}),"\n",(0,a.jsx)(n.h2,{id:"events-and-double-buffered-eventbus",children:"Events and double-buffered EventBus"}),"\n",(0,a.jsxs)(n.p,{children:["In addition, systems can emit Events in frame N, e.g. ",(0,a.jsx)(n.strong,{children:"request events"})," - events that intend to mutate the world state - or plain signals such as ",(0,a.jsx)(n.code,{children:"SolidCollisionEvent"}),", from which world-mutating Commands (despawn) can be derived.\nThe EventBus is double-buffered (",(0,a.jsx)(n.code,{children:"helios.core.data.TypeIndexedDoubleBuffer"}),"): events are written into the write buffer in frame N and become visible in the read buffer only after a buffer swap (",(0,a.jsx)(n.code,{children:"swapBuffers()"}),") at the beginning of frame N+1."]}),"\n",(0,a.jsx)(n.p,{children:"At the beginning of frame N+1, events are dispatched from the read buffer. As mentioned above, request events can be translated into Commands and written into the CommandBuffer."}),"\n",(0,a.jsx)(n.p,{children:"This yields the following order at the beginning of frame N+1:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"EventBus.swapBuffers()\n\nEventBus.dispatch() // Events from which Commands may be generated\n\nCommandBuffer.flush() // Commit - mutates the world state,\n                      // optional manager-based command processing\n"})}),"\n",(0,a.jsx)(n.h3,{id:"optional-manager-based-command-processing",children:"Optional manager-based command processing"}),"\n",(0,a.jsxs)(n.p,{children:["Instead of having each Command fully implement the mutation logic in ",(0,a.jsx)(n.code,{children:"execute()"}),", the CommandBuffer can additionally hold registered managers. In this model, ",(0,a.jsx)(n.code,{children:"execute()"})," primarily performs a registering/planning step, and the managers then process their work as a coordinated batch."]}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"CommandBuffer::flush() {\n    for (auto& cmd : commands)\n        cmd->execute();   // in execute e.g.:\n                          // spawnManager->enqueue(position, enemyType);\n\n    for (auto& mgr : managers)\n        mgr->process();   // the spawnManager processes the spawn list\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"This model allows Commands to be bundled, sorted, and processed deterministically (e.g. handle all spawns first, then all despawns)."}),"\n",(0,a.jsx)(n.h2,{id:"immediate-events-single-buffered",children:"Immediate Events (single-buffered)"}),"\n",(0,a.jsxs)(n.p,{children:["For time-critical feedback that does not mutate the world state (particle effects, audio feedback), there is a separate ",(0,a.jsx)(n.strong,{children:"ImmediateBus"})," (single-buffered).\nImmediate events should be processed within the same frame without additional double-buffer latency. A suitable dispatch point is after ",(0,a.jsx)(n.code,{children:"CommandBuffer.flush()"}),', so that feedback can observe the world that was committed at the beginning of the frame in a consistent state. This mitigates latency (e.g. ~16ms at 60fps) and allows feedback to be triggered in the same frame as a specific event, which improves the overall user experience ("game feel").']}),"\n",(0,a.jsx)(n.h2,{id:"frame-order-summary",children:"Frame Order Summary"}),"\n",(0,a.jsx)(n.p,{children:"Overall, the frame-begin order becomes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"EventBus.swapBuffers() // input\nEventBus.dispatch()\n\nCommandBuffer.flush() // mutation\n\nImmediateBus.dispatch() // signals\n\n// gameplay systems updating physics\nMove2DSystem.update();\n// ...\n"})})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}}}]);