"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[75738],{22702:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>c,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"core-concepts/ecs/component-ops","title":"ComponentOps","description":"Function pointers for type-erased component lifecycle callbacks.","source":"@site/docs/core-concepts/ecs/component-ops.md","sourceDirName":"core-concepts/ecs","slug":"/core-concepts/ecs/component-ops","permalink":"/docs/core-concepts/ecs/component-ops","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/ecs/component-ops.md","tags":[{"inline":true,"label":"ecs","permalink":"/docs/tags/ecs"},{"inline":true,"label":"architecture","permalink":"/docs/tags/architecture"},{"inline":true,"label":"reflection","permalink":"/docs/tags/reflection"}],"version":"current","sidebarPosition":9,"frontMatter":{"title":"ComponentOps","description":"Function pointers for type-erased component lifecycle callbacks.","slug":"/core-concepts/ecs/component-ops","sidebar_label":"ComponentOps","sidebar_position":9,"tags":["ecs","architecture","reflection"],"keywords":["helios","ComponentOps","ECS","function pointers","type erasure"]},"sidebar":"tutorialSidebar","previous":{"title":"Traits","permalink":"/docs/core-concepts/ecs/traits"},"next":{"title":"Sparse Set","permalink":"/docs/core-concepts/sparse-set"}}');var s=t(74848),i=t(28453);const c={title:"ComponentOps",description:"Function pointers for type-erased component lifecycle callbacks.",slug:"/core-concepts/ecs/component-ops",sidebar_label:"ComponentOps",sidebar_position:9,tags:["ecs","architecture","reflection"],keywords:["helios","ComponentOps","ECS","function pointers","type erasure"]},r="ComponentOps",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Function Pointers",id:"function-pointers",level:2},{value:"Type Erasure Pattern",id:"type-erasure-pattern",level:2},{value:"Clone Function",id:"clone-function",level:2},{value:"Null Checks",id:"null-checks",level:2},{value:"Overview",id:"overview-1",level:2},{value:"API",id:"api",level:2},{value:"setOps()",id:"setops",level:3},{value:"ops()",id:"ops",level:3},{value:"Internal Storage",id:"internal-storage",level:2},{value:"Usage Pattern",id:"usage-pattern",level:2},{value:"Thread Safety",id:"thread-safety",level:2},{value:"See Also",id:"see-also",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"componentops",children:"ComponentOps"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"ComponentOps"})," is a struct containing function pointers for component lifecycle callbacks. It enables type-erased invocation of lifecycle hooks at runtime while maintaining compile-time type safety during registration."]}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct ComponentOps {\n    using OnAcquireFn = void(*)(void*);\n    using OnReleaseFn = void(*)(void*);\n    using OnRemoveFn = bool(*)(void*);\n    using EnableFn = void(*)(void*);\n    using DisableFn = void(*)(void*);\n    using CloneFn = void*(*)(void* manager, const void* source, const EntityHandle* target);\n    using OnActivateFn = void(*)(void*);\n    using OnDeactivateFn = void(*)(void*);\n\n    OnAcquireFn onAcquire = nullptr;\n    OnReleaseFn onRelease = nullptr;\n    OnRemoveFn onRemove = nullptr;\n    EnableFn enable = nullptr;\n    DisableFn disable = nullptr;\n    CloneFn clone = nullptr;\n    OnActivateFn onActivate = nullptr;\n    OnDeactivateFn onDeactivate = nullptr;\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"function-pointers",children:"Function Pointers"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Pointer"}),(0,s.jsx)(n.th,{children:"Signature"}),(0,s.jsx)(n.th,{children:"Purpose"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"onAcquire"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"void(void*)"})}),(0,s.jsx)(n.td,{children:"Called when entity acquired from pool"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"onRelease"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"void(void*)"})}),(0,s.jsx)(n.td,{children:"Called when entity released to pool"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"onRemove"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"bool(void*)"})}),(0,s.jsx)(n.td,{children:"Called before removal, return false to block"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"enable"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"void(void*)"})}),(0,s.jsx)(n.td,{children:"Enable component"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"disable"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"void(void*)"})}),(0,s.jsx)(n.td,{children:"Disable component"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"clone"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"void*(void*, const void*, const EntityHandle*)"})}),(0,s.jsx)(n.td,{children:"Clone component to target entity"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"onActivate"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"void(void*)"})}),(0,s.jsx)(n.td,{children:"Called when GameObject activated"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"onDeactivate"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"void(void*)"})}),(0,s.jsx)(n.td,{children:"Called when GameObject deactivated"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"type-erasure-pattern",children:"Type Erasure Pattern"}),"\n",(0,s.jsx)(n.p,{children:"ComponentOps enables calling methods on components without knowing their concrete type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// At registration time (type known):\nComponentOps ops{\n    .onAcquire = [](void* ptr) {\n        static_cast<HealthComponent*>(ptr)->onAcquire();\n    }\n};\n\n// At runtime (type erased):\nvoid* component = getComponent(entityId, typeId);\nconst auto& ops = ComponentOpsRegistry::ops(typeId);\nif (ops.onAcquire) {\n    ops.onAcquire(component);  // No type info needed\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"clone-function",children:"Clone Function"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"clone"})," function pointer has a special signature for component copying:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using CloneFn = void*(*)(\n    void* manager,           // EntityManager for emplace\n    const void* source,      // Source component data\n    const EntityHandle* target  // Target entity handle\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Implementation in ComponentReflector:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:".clone = [](void* managerRaw, const void* sourceRaw, const EntityHandle* target) -> void* {\n    auto* manager = static_cast<EntityManager*>(managerRaw);\n    const auto* source = static_cast<const T*>(sourceRaw);\n    \n    // Copy construct into target entity\n    T* cmp = manager->emplace<T>(*target, *source);\n    \n    // Call onClone if implemented\n    if constexpr (traits::HasClone<T>) {\n        cmp->onClone(*source);\n    }\n    \n    return cmp;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"null-checks",children:"Null Checks"}),"\n",(0,s.jsxs)(n.p,{children:["Function pointers are ",(0,s.jsx)(n.code,{children:"nullptr"})," if the component doesn't implement the corresponding hook:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"const auto& ops = ComponentOpsRegistry::ops(typeId);\n\n// Safe invocation pattern\nif (ops.onAcquire) {\n    ops.onAcquire(rawComponent);\n}\n\n// Or use helper that checks internally\nops.onRemove ? ops.onRemove(raw) : true;\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h1,{id:"componentopsregistry",children:"ComponentOpsRegistry"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"ComponentOpsRegistry"})," is a global registry that maps ",(0,s.jsx)(n.code,{children:"ComponentTypeId"})," to ",(0,s.jsx)(n.code,{children:"ComponentOps"}),". It provides O(1) lookup for lifecycle function pointers."]}),"\n",(0,s.jsx)(n.h2,{id:"overview-1",children:"Overview"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class ComponentOpsRegistry {\n    inline static std::vector<ComponentOps> operations_;\n    inline static constexpr ComponentOps emptyOps_{};\n\npublic:\n    static void setOps(ComponentTypeId typeId, const ComponentOps& ops);\n    static const ComponentOps& ops(ComponentTypeId typeId);\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"api",children:"API"}),"\n",(0,s.jsx)(n.h3,{id:"setops",children:"setOps()"}),"\n",(0,s.jsx)(n.p,{children:"Registers ComponentOps for a type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"static void setOps(ComponentTypeId typeId, const ComponentOps& ops);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Called by ",(0,s.jsx)(n.code,{children:"ComponentReflector::registerType<T>()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"ComponentOps ops{ /* ... */ };\nComponentOpsRegistry::setOps(ComponentTypeId::id<T>(), ops);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"ops",children:"ops()"}),"\n",(0,s.jsx)(n.p,{children:"Retrieves ComponentOps for a type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"static const ComponentOps& ops(ComponentTypeId typeId);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Returns a reference to empty ops if the type is not registered:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"const auto& ops = ComponentOpsRegistry::ops(typeId);\n// ops.onAcquire may be nullptr if not registered\n"})}),"\n",(0,s.jsx)(n.h2,{id:"internal-storage",children:"Internal Storage"}),"\n",(0,s.jsx)(n.p,{children:"Uses a type-indexed vector for O(1) access:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"operations_[typeId.value()] = ops;\n"})}),"\n",(0,s.jsx)(n.p,{children:"The vector auto-resizes when new types are registered:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"if (typeId.value() >= operations_.size()) {\n    operations_.resize(typeId.value() + 1);\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"usage-pattern",children:"Usage Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// During bootstrap (type registration)\nhelios::engine::bootstrap::registerAllComponents();\n\n// During gameplay (type-erased invocation)\nfor (auto typeId : entity.componentTypeIds()) {\n    const auto& ops = ComponentOpsRegistry::ops(typeId);\n    void* raw = entityManager.raw(handle, typeId);\n    \n    if (ops.onRelease) {\n        ops.onRelease(raw);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ComponentOpsRegistry"})," is ",(0,s.jsx)(n.strong,{children:"not thread-safe"}),". All registration must complete before any concurrent access. In practice, call ",(0,s.jsx)(n.code,{children:"registerAllComponents()"})," once during startup before any systems run."]}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/ecs/traits",children:"Traits"})," - Compile-time hook detection"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/component-registry",children:"Component Registry"})," - High-level registration API"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/component-lifecycle",children:"Component Lifecycle"})," - Lifecycle hook details"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>r});var o=t(96540);const s={},i=o.createContext(s);function c(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);