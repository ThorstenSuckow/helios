"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[45538],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var s=t(96540);const o={},c=s.createContext(o);function i(e){const n=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(c.Provider,{value:n},e.children)}},75419:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"core-concepts/ecs/gameobject","title":"GameObject","description":"High-level entity wrapper providing type-safe component access and lifecycle management.","source":"@site/docs/core-concepts/ecs/gameobject.md","sourceDirName":"core-concepts/ecs","slug":"/core-concepts/ecs/gameobject","permalink":"/docs/core-concepts/ecs/gameobject","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/ecs/gameobject.md","tags":[{"inline":true,"label":"ecs","permalink":"/docs/tags/ecs"},{"inline":true,"label":"architecture","permalink":"/docs/tags/architecture"},{"inline":true,"label":"entity","permalink":"/docs/tags/entity"}],"version":"current","sidebarPosition":1,"frontMatter":{"title":"GameObject","description":"High-level entity wrapper providing type-safe component access and lifecycle management.","slug":"/core-concepts/ecs/gameobject","sidebar_label":"GameObject","sidebar_position":1,"tags":["ecs","architecture","entity"],"keywords":["helios","GameObject","ECS","entity","component","facade"]},"sidebar":"tutorialSidebar","previous":{"title":"Component Structure","permalink":"/docs/core-concepts/ecs/component-structure"},"next":{"title":"EntityManager","permalink":"/docs/core-concepts/ecs/entity-manager"}}');var o=t(74848),c=t(28453);const i={title:"GameObject",description:"High-level entity wrapper providing type-safe component access and lifecycle management.",slug:"/core-concepts/ecs/gameobject",sidebar_label:"GameObject",sidebar_position:1,tags:["ecs","architecture","entity"],keywords:["helios","GameObject","ECS","entity","component","facade"]},a="GameObject",r={},l=[{value:"Overview",id:"overview",level:2},{value:"API Reference",id:"api-reference",level:2},{value:"Construction",id:"construction",level:3},{value:"Component Operations",id:"component-operations",level:3},{value:"Adding Components",id:"adding-components",level:4},{value:"Retrieving Components",id:"retrieving-components",level:4},{value:"Activation State",id:"activation-state",level:3},{value:"Lifecycle Hooks",id:"lifecycle-hooks",level:3},{value:"Component Iteration",id:"component-iteration",level:3},{value:"Entity Handle Access",id:"entity-handle-access",level:3},{value:"Internal Structure",id:"internal-structure",level:2},{value:"Pass by Value",id:"pass-by-value",level:3},{value:"Relationship with Other Classes",id:"relationship-with-other-classes",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Example: Complete Entity Setup",id:"example-complete-entity-setup",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"gameobject",children:"GameObject"})}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.strong,{children:"GameObject"})," is the primary interface for interacting with entities in the helios ECS. It provides a convenient, type-safe wrapper around an ",(0,o.jsx)(n.code,{children:"EntityHandle"})," and the ",(0,o.jsx)(n.code,{children:"EntityManager"}),", enabling component manipulation without direct access to low-level ECS internals."]}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"GameObject"})," acts as a ",(0,o.jsx)(n.strong,{children:"facade"})," that combines:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["An ",(0,o.jsx)(n.code,{children:"EntityHandle"})," identifying the entity"]}),"\n",(0,o.jsxs)(n.li,{children:["A pointer to the ",(0,o.jsx)(n.code,{children:"EntityManager"})," that owns the entity's data"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This design keeps the handle lightweight while providing rich functionality through the manager."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// GameObject is typically obtained from GameWorld\nauto player = gameWorld.addGameObject();\n\n// Add components\nplayer.add<TransformComponent>(glm::vec3{0.0f});\nplayer.add<HealthComponent>(100.0f);\nplayer.add<RenderableComponent>(mesh);\n\n// Query components\nif (player.has<HealthComponent>()) {\n    auto* health = player.get<HealthComponent>();\n    health->takeDamage(10.0f);\n}\n\n// Activate/deactivate\nplayer.setActive(false);  // Marks as inactive, calls onDeactivate()\nplayer.setActive(true);   // Marks as active, calls onActivate()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,o.jsx)(n.h3,{id:"construction",children:"Construction"}),"\n",(0,o.jsxs)(n.p,{children:["GameObjects are created through ",(0,o.jsx)(n.code,{children:"GameWorld"}),", not directly instantiated:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Correct - obtain from GameWorld\nauto entity = gameWorld.addGameObject();\n\n// Correct - lookup existing\nauto entity = gameWorld.gameObject(entityHandle);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"component-operations",children:"Component Operations"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Method"}),(0,o.jsx)(n.th,{children:"Description"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"add<T>(args...)"})}),(0,o.jsx)(n.td,{children:"Constructs and attaches a component"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"get<T>()"})}),(0,o.jsx)(n.td,{children:"Returns pointer to component (or nullptr)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"getOrAdd<T>(args...)"})}),(0,o.jsx)(n.td,{children:"Returns existing or creates new component"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"has<T>()"})}),(0,o.jsx)(n.td,{children:"Checks if component is attached"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"has(typeId)"})}),(0,o.jsx)(n.td,{children:"Checks by runtime type ID"})]})]})]}),"\n",(0,o.jsx)(n.h4,{id:"adding-components",children:"Adding Components"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Add with constructor arguments\nauto& transform = player.add<TransformComponent>(position, rotation, scale);\n\n// Add with default constructor\nauto& health = player.add<HealthComponent>();\n\n// Get existing or add new\nauto& collider = player.getOrAdd<CollisionComponent>();\n"})}),"\n",(0,o.jsx)(n.h4,{id:"retrieving-components",children:"Retrieving Components"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Returns nullptr if not found\nauto* transform = player.get<TransformComponent>();\nif (transform) {\n    transform->setPosition(newPos);\n}\n\n// Const version for read-only access\nconst auto* health = player.get<HealthComponent>();\n"})}),"\n",(0,o.jsx)(n.h3,{id:"activation-state",children:"Activation State"}),"\n",(0,o.jsx)(n.p,{children:"GameObjects can be activated or deactivated, which propagates to all attached components:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Deactivate - adds Inactive tag, calls onDeactivate()\nplayer.setActive(false);\n\n// Activate - adds Active tag, calls onActivate()\nplayer.setActive(true);\n\n// Query state\nif (player.isActive()) {\n    // ...\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"When deactivated:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["An ",(0,o.jsx)(n.code,{children:"Inactive"})," tag component is added"]}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"Active"})," tag component is removed"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"onDeactivate()"})," is called on components that support it"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"When activated:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"Inactive"})," tag component is removed"]}),"\n",(0,o.jsxs)(n.li,{children:["An ",(0,o.jsx)(n.code,{children:"Active"})," tag component is added"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"onActivate()"})," is called on components that support it"]}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Note:"})," ",(0,o.jsx)(n.code,{children:"setActive()"})," does ",(0,o.jsx)(n.strong,{children:"not"})," call ",(0,o.jsx)(n.code,{children:"enable()"}),"/",(0,o.jsx)(n.code,{children:"disable()"}),". Use ",(0,o.jsx)(n.code,{children:"enableComponent()"}),"/",(0,o.jsx)(n.code,{children:"disableComponent()"})," for individual component toggling."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"lifecycle-hooks",children:"Lifecycle Hooks"}),"\n",(0,o.jsx)(n.p,{children:"GameObjects provide methods to trigger lifecycle hooks on all attached components:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Called when acquired from object pool\nplayer.onAcquire();\n\n// Called when released back to pool\nplayer.onRelease();\n"})}),"\n",(0,o.jsx)(n.p,{children:"These methods iterate through all components and invoke the corresponding hooks if implemented."}),"\n",(0,o.jsx)(n.h3,{id:"component-iteration",children:"Component Iteration"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Iterate over all component type IDs\nfor (auto typeId : player.componentTypeIds()) {\n    void* raw = player.raw(typeId);\n    // Process component...\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"entity-handle-access",children:"Entity Handle Access"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Get the underlying handle\nEntityHandle handle = player.entityHandle();\n\n// Handles can be stored and compared\nif (handle == otherHandle) {\n    // Same entity\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"internal-structure",children:"Internal Structure"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"class GameObject {\n    EntityHandle entityHandle_;      // 8 bytes (EntityId + VersionId)\n    EntityManager* entityManager_;   // 8 bytes (pointer)\n    \n    // ...methods delegate to entityManager_\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"GameObject"})," itself is:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Lightweight"})," (~16 bytes) - smaller than most smart pointers"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Copyable"})," - multiple GameObjects can reference the same entity"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Non-owning"})," - does not manage entity lifetime"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Pass-by-value friendly"})," - should be passed by value, not by reference"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"pass-by-value",children:"Pass by Value"}),"\n",(0,o.jsxs)(n.p,{children:["Due to its small size, ",(0,o.jsx)(n.code,{children:"GameObject"})," should be passed ",(0,o.jsx)(n.strong,{children:"by value"})," rather than by reference or pointer:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Correct - pass by value\nvoid processEntity(GameObject entity) {\n    entity.get<HealthComponent>()->takeDamage(10.0f);\n}\n\n// Unnecessary - reference adds indirection for no benefit\nvoid processEntity(GameObject& entity);      // Avoid\nvoid processEntity(const GameObject& entity); // Avoid\n\n// Wrong - never use pointers for GameObject\nvoid processEntity(GameObject* entity);       // Never do this\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Copying a ",(0,o.jsx)(n.code,{children:"GameObject"})," is essentially copying two integers and a pointer - faster than dereferencing a reference in most cases."]}),"\n",(0,o.jsx)(n.h2,{id:"relationship-with-other-classes",children:"Relationship with Other Classes"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        GameWorld                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502  EntityRegistry  \u2502\u25c4\u2500\u2500\u2500\u2502      EntityManager         \u2502     \u2502\n\u2502  \u2502  (handle alloc)  \u2502    \u2502  (component storage)       \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502           \u2502                          \u25b2                      \u2502\n\u2502           \u25bc                          \u2502                      \u2502\n\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502    \u2502 EntityHandle \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502  GameObject  \u2502              \u2502\n\u2502    \u2502 (id+version) \u2502           \u2502   (facade)   \u2502              \u2502\n\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Don't store GameObjects long-term"})," - Store ",(0,o.jsx)(n.code,{children:"EntityHandle"})," instead and resolve via ",(0,o.jsx)(n.code,{children:"GameWorld::gameObject()"})]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Check component existence"})," - Use ",(0,o.jsx)(n.code,{children:"has<T>()"})," before ",(0,o.jsx)(n.code,{children:"get<T>()"})," or handle nullptr returns"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use getOrAdd for optional components"})," - Simplifies code when components may or may not exist"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Prefer type-safe methods"})," - Use ",(0,o.jsx)(n.code,{children:"has<T>()"})," over ",(0,o.jsx)(n.code,{children:"has(typeId)"})," when possible"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Leverage setActive for pooling"})," - Deactivate instead of destroying for pooled objects"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"example-complete-entity-setup",children:"Example: Complete Entity Setup"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"auto enemy = gameWorld.addGameObject();\n\n// Transform\nenemy.add<ComposeTransformComponent>();\nenemy.add<TranslationStateComponent>(spawnPosition);\nenemy.add<ScaleStateComponent>(enemySize);\nenemy.add<RotationStateComponent>();\n\n// Rendering\nauto& renderable = enemy.add<RenderableComponent>(mesh);\nenemy.add<SceneNodeComponent>(sceneNode);\nenemy.add<ModelAabbComponent>(renderable.localAABB());\n\n// Physics\nenemy.add<CollisionComponent>(CollisionLayer::Enemy);\nenemy.add<AabbColliderComponent>();\nenemy.add<Move2DComponent>(speed);\nenemy.add<DirectionComponent>();\n\n// Gameplay\nenemy.add<HealthComponent>(100.0f);\nenemy.add<DamageDealerComponent>();\n\n// Pooling support\nenemy.add<SpawnedByProfileComponent>();\n"})}),"\n",(0,o.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/ecs/entity-manager",children:"EntityManager"})," - Low-level entity and component management"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/ecs/entity-handle",children:"EntityHandle"})," - Versioned entity reference"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/ecs/view",children:"View"})," - Component-based entity queries"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/ecs/system",children:"System"})," - Game logic processors"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/component-lifecycle",children:"Component Lifecycle"})," - Lifecycle hooks"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/component-system",children:"Component System"})," - ECS architecture overview"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/sparse-set",children:"Sparse Set"})," - Underlying component storage"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);