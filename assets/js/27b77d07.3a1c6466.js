"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[81481],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>l});var s=n(96540);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}},89834:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"core-concepts/ecs/updatable","title":"Updatable","description":"Interface for objects requiring per-frame updates in the game loop.","source":"@site/docs/core-concepts/ecs/updatable.md","sourceDirName":"core-concepts/ecs","slug":"/core-concepts/ecs/updatable","permalink":"/docs/core-concepts/ecs/updatable","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/ecs/updatable.md","tags":[{"inline":true,"label":"ecs","permalink":"/docs/tags/ecs"},{"inline":true,"label":"architecture","permalink":"/docs/tags/architecture"},{"inline":true,"label":"interface","permalink":"/docs/tags/interface"}],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Updatable","description":"Interface for objects requiring per-frame updates in the game loop.","slug":"/core-concepts/ecs/updatable","sidebar_label":"Updatable","sidebar_position":7,"tags":["ecs","architecture","interface"],"keywords":["helios","Updatable","ECS","update","game loop"]},"sidebar":"tutorialSidebar","previous":{"title":"System","permalink":"/docs/core-concepts/ecs/system"},"next":{"title":"Traits","permalink":"/docs/core-concepts/ecs/traits"}}');var a=n(74848),i=n(28453);const r={title:"Updatable",description:"Interface for objects requiring per-frame updates in the game loop.",slug:"/core-concepts/ecs/updatable",sidebar_label:"Updatable",sidebar_position:7,tags:["ecs","architecture","interface"],keywords:["helios","Updatable","ECS","update","game loop"]},l="Updatable",c={},o=[{value:"Overview",id:"overview",level:2},{value:"Usage",id:"usage",level:2},{value:"Implementing Updatable",id:"implementing-updatable",level:3},{value:"UpdateContext",id:"updatecontext",level:3},{value:"Design Rationale",id:"design-rationale",level:2},{value:"noexcept Requirement",id:"noexcept-requirement",level:3},{value:"Interface Segregation",id:"interface-segregation",level:3},{value:"Relationship with System",id:"relationship-with-system",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"updatable",children:"Updatable"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.strong,{children:"Updatable"})," interface defines the contract for objects that require per-frame updates. It is the base interface for ",(0,a.jsx)(t.code,{children:"System"})," and can be implemented by any class that needs to participate in the game loop."]}),"\n",(0,a.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"class Updatable {\npublic:\n    virtual ~Updatable() = default;\n    virtual void update(UpdateContext& updateContext) noexcept = 0;\n};\n"})}),"\n",(0,a.jsx)(t.p,{children:"The interface is intentionally minimal:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Single pure virtual method ",(0,a.jsx)(t.code,{children:"update()"})]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"noexcept"})," guarantee for exception safety in the game loop"]}),"\n",(0,a.jsx)(t.li,{children:"Virtual destructor for proper cleanup"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,a.jsx)(t.h3,{id:"implementing-updatable",children:"Implementing Updatable"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"class PhysicsSystem : public System {  // System inherits from Updatable\npublic:\n    void update(UpdateContext& ctx) noexcept override {\n        // Called every frame\n        float dt = ctx.deltaTime;\n        // Process physics...\n    }\n};\n"})}),"\n",(0,a.jsx)(t.h3,{id:"updatecontext",children:"UpdateContext"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"update()"})," method receives an ",(0,a.jsx)(t.code,{children:"UpdateContext"})," with frame information:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"struct UpdateContext {\n    float deltaTime;           // Time since last frame (seconds)\n    CommandBuffer* commands;   // For deferred operations\n    GameWorld* gameWorld;      // Reference to the world\n};\n"})}),"\n",(0,a.jsx)(t.h2,{id:"design-rationale",children:"Design Rationale"}),"\n",(0,a.jsx)(t.h3,{id:"noexcept-requirement",children:"noexcept Requirement"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"update()"})," method is marked ",(0,a.jsx)(t.code,{children:"noexcept"})," because:"]}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Game loop stability"})," - Exceptions during update can crash the game"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Performance"})," - ",(0,a.jsx)(t.code,{children:"noexcept"})," enables compiler optimizations"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Predictability"})," - Forces error handling at the source"]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:'void update(UpdateContext& ctx) noexcept override {\n    // Must handle all errors internally\n    if (auto result = riskyOperation(); !result) {\n        LOG_ERROR("Operation failed");\n        return;  // Don\'t throw\n    }\n}\n'})}),"\n",(0,a.jsx)(t.h3,{id:"interface-segregation",children:"Interface Segregation"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"Updatable"})," is separate from ",(0,a.jsx)(t.code,{children:"System"})," to allow:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Non-system objects to be updatable"}),"\n",(0,a.jsx)(t.li,{children:"Systems that don't need updates (rare)"}),"\n",(0,a.jsx)(t.li,{children:"Composition over inheritance patterns"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"relationship-with-system",children:"Relationship with System"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"System"})," extends ",(0,a.jsx)(t.code,{children:"Updatable"})," and adds:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"GameWorld*"})," member for world access"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"init()"})," callback for initialization"]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"class System : public Updatable {\nprotected:\n    GameWorld* gameWorld_ = nullptr;\n    \npublic:\n    virtual void init(GameWorld& gameWorld) noexcept;\n    void update(UpdateContext& ctx) noexcept override = 0;\n};\n"})}),"\n",(0,a.jsx)(t.h2,{id:"see-also",children:"See Also"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"/docs/core-concepts/ecs/system",children:"System"})," - Game logic processor using Updatable"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"/docs/core-concepts/gameloop-architecture",children:"Game Loop Architecture"})," - How updates are dispatched"]}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);