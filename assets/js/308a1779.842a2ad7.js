"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[6919],{13680:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"core-concepts/ecs/traits","title":"Traits","description":"Compile-time detection of component lifecycle hooks using C++20 concepts.","source":"@site/docs/core-concepts/ecs/traits.md","sourceDirName":"core-concepts/ecs","slug":"/core-concepts/ecs/traits","permalink":"/docs/core-concepts/ecs/traits","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/ecs/traits.md","tags":[{"inline":true,"label":"ecs","permalink":"/docs/tags/ecs"},{"inline":true,"label":"architecture","permalink":"/docs/tags/architecture"},{"inline":true,"label":"concepts","permalink":"/docs/tags/concepts"}],"version":"current","sidebarPosition":8,"frontMatter":{"title":"Traits","description":"Compile-time detection of component lifecycle hooks using C++20 concepts.","slug":"/core-concepts/ecs/traits","sidebar_label":"Traits","sidebar_position":8,"tags":["ecs","architecture","concepts"],"keywords":["helios","Traits","ECS","concepts","compile-time","lifecycle"]},"sidebar":"tutorialSidebar","previous":{"title":"Updatable","permalink":"/docs/core-concepts/ecs/updatable"},"next":{"title":"ComponentOps","permalink":"/docs/core-concepts/ecs/component-ops"}}');var i=t(74848),c=t(28453);const o={title:"Traits",description:"Compile-time detection of component lifecycle hooks using C++20 concepts.",slug:"/core-concepts/ecs/traits",sidebar_label:"Traits",sidebar_position:8,tags:["ecs","architecture","concepts"],keywords:["helios","Traits","ECS","concepts","compile-time","lifecycle"]},r="Traits",l={},a=[{value:"Overview",id:"overview",level:2},{value:"Available Traits",id:"available-traits",level:2},{value:"Trait Definitions",id:"trait-definitions",level:2},{value:"HasOnAcquire",id:"hasonacquire",level:3},{value:"HasOnRelease",id:"hasonrelease",level:3},{value:"HasOnRemove",id:"hasonremove",level:3},{value:"HasToogleable",id:"hastoogleable",level:3},{value:"HasClone",id:"hasclone",level:3},{value:"HasActivatable",id:"hasactivatable",level:3},{value:"Usage in ComponentReflector",id:"usage-in-componentreflector",level:2},{value:"Implementing Traits in Components",id:"implementing-traits-in-components",level:2},{value:"Performance",id:"performance",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"traits",children:"Traits"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"Traits"})," module provides compile-time detection of component lifecycle hooks using C++20 concepts. This enables zero-overhead conditional invocation of optional methods."]}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Traits use concepts to detect if a type implements specific methods:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"template<typename T>\nconcept HasOnAcquire = requires(T t) {\n    {t.onAcquire()} -> std::same_as<void>;\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["At compile time, the ",(0,i.jsx)(n.code,{children:"ComponentReflector"})," uses these traits to generate appropriate function pointers, avoiding runtime checks."]}),"\n",(0,i.jsx)(n.h2,{id:"available-traits",children:"Available Traits"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Trait"}),(0,i.jsx)(n.th,{children:"Required Method"}),(0,i.jsx)(n.th,{children:"Return Type"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"HasOnAcquire"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"onAcquire()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"void"})}),(0,i.jsx)(n.td,{children:"Pool acquisition callback"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"HasOnRelease"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"onRelease()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"void"})}),(0,i.jsx)(n.td,{children:"Pool release callback"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"HasOnRemove"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"onRemove()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bool"})}),(0,i.jsx)(n.td,{children:"Removal interception"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"HasToogleable"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"enable()"}),", ",(0,i.jsx)(n.code,{children:"disable()"})]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"void"})}),(0,i.jsx)(n.td,{children:"Component enable/disable"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"HasClone"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"onClone(const T&)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"void"})}),(0,i.jsx)(n.td,{children:"Post-copy initialization"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"HasActivatable"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"onActivate()"}),", ",(0,i.jsx)(n.code,{children:"onDeactivate()"})]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"void"})}),(0,i.jsx)(n.td,{children:"GameObject activation"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"trait-definitions",children:"Trait Definitions"}),"\n",(0,i.jsx)(n.h3,{id:"hasonacquire",children:"HasOnAcquire"}),"\n",(0,i.jsx)(n.p,{children:"Detects components that need initialization when acquired from a pool:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"template<typename T>\nconcept HasOnAcquire = requires(T t) {\n    {t.onAcquire()} -> std::same_as<void>;\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"hasonrelease",children:"HasOnRelease"}),"\n",(0,i.jsx)(n.p,{children:"Detects components that need cleanup when released to a pool:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"template<typename T>\nconcept HasOnRelease = requires(T t) {\n    {t.onRelease()} -> std::same_as<void>;\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"hasonremove",children:"HasOnRemove"}),"\n",(0,i.jsx)(n.p,{children:"Detects components that can intercept removal:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"template<typename T>\nconcept HasOnRemove = requires(T t) {\n    {t.onRemove()} -> std::convertible_to<bool>;\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Returns ",(0,i.jsx)(n.code,{children:"true"})," to allow removal, ",(0,i.jsx)(n.code,{children:"false"})," to prevent it."]}),"\n",(0,i.jsx)(n.h3,{id:"hastoogleable",children:"HasToogleable"}),"\n",(0,i.jsx)(n.p,{children:"Detects components that can be enabled/disabled:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"template<typename T>\nconcept HasToogleable = requires(T t) {\n    {t.disable()} -> std::same_as<void>;\n    {t.enable()} -> std::same_as<void>;\n};\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," Both methods must be present for the trait to be satisfied."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"hasclone",children:"HasClone"}),"\n",(0,i.jsx)(n.p,{children:"Detects components that need post-copy initialization:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"template<typename T>\nconcept HasClone = requires(T t, const T& source) {\n    {t.onClone(source)} -> std::same_as<void>;\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"hasactivatable",children:"HasActivatable"}),"\n",(0,i.jsx)(n.p,{children:"Detects components that respond to GameObject activation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"template<typename T>\nconcept HasActivatable = requires(T t) {\n    {t.onActivate()} -> std::same_as<void>;\n    {t.onDeactivate()} -> std::same_as<void>;\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"usage-in-componentreflector",children:"Usage in ComponentReflector"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ComponentReflector"})," uses traits with ",(0,i.jsx)(n.code,{children:"if constexpr"})," for zero-overhead dispatch:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"template<typename T>\nstatic void registerType() {\n    ComponentOps ops{\n        .onAcquire = [](void* ptr) {\n            if constexpr (traits::HasOnAcquire<T>) {\n                static_cast<T*>(ptr)->onAcquire();\n            }\n        },\n        \n        .onRemove = [](void* ptr) -> bool {\n            if constexpr (traits::HasOnRemove<T>) {\n                return static_cast<T*>(ptr)->onRemove();\n            }\n            return true;\n        },\n        \n        // ... other hooks\n    };\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"implementing-traits-in-components",children:"Implementing Traits in Components"}),"\n",(0,i.jsx)(n.p,{children:"Components opt-in to lifecycle hooks by implementing the required methods:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"class HealthComponent {\n    float health_;\n    float maxHealth_;\n\npublic:\n    // Satisfies HasOnAcquire\n    void onAcquire() noexcept {\n        health_ = maxHealth_;\n    }\n    \n    // Satisfies HasOnRelease\n    void onRelease() noexcept {\n        health_ = maxHealth_;\n    }\n};\n\n// Compile-time verification\nstatic_assert(traits::HasOnAcquire<HealthComponent>);\nstatic_assert(traits::HasOnRelease<HealthComponent>);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance",children:"Performance"}),"\n",(0,i.jsxs)(n.p,{children:["Traits provide ",(0,i.jsx)(n.strong,{children:"zero runtime overhead"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compile-time detection"})," - No runtime type checks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dead code elimination"})," - Empty ",(0,i.jsx)(n.code,{children:"if constexpr"})," branches are removed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Inlining"})," - Lambda bodies are typically inlined"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// If T doesn't have onAcquire(), this compiles to nothing:\nif constexpr (traits::HasOnAcquire<T>) {\n    ptr->onAcquire();  // Only compiled if trait is satisfied\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/core-concepts/component-lifecycle",children:"Component Lifecycle"})," - How hooks are used"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/core-concepts/ecs/component-ops",children:"ComponentOps"})," - Function pointers generated from traits"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/core-concepts/component-registry",children:"Component Registry"})," - Registration using traits"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(96540);const i={},c=s.createContext(i);function o(e){const n=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);