"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[48918],{28453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>o});var t=i(96540);const s={},r=t.createContext(s);function c(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),t.createElement(r.Provider,{value:n},e.children)}},84941:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"core-concepts/ecs/view","title":"View","description":"Lightweight iterator for querying entities with specific components.","source":"@site/docs/core-concepts/ecs/view.md","sourceDirName":"core-concepts/ecs","slug":"/core-concepts/ecs/view","permalink":"/docs/core-concepts/ecs/view","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/ecs/view.md","tags":[{"inline":true,"label":"ecs","permalink":"/docs/tags/ecs"},{"inline":true,"label":"architecture","permalink":"/docs/tags/architecture"},{"inline":true,"label":"query","permalink":"/docs/tags/query"}],"version":"current","sidebarPosition":5,"frontMatter":{"title":"View","description":"Lightweight iterator for querying entities with specific components.","slug":"/core-concepts/ecs/view","sidebar_label":"View","sidebar_position":5,"tags":["ecs","architecture","query"],"keywords":["helios","View","ECS","component query","iteration"]},"sidebar":"tutorialSidebar","previous":{"title":"EntityHandle","permalink":"/docs/core-concepts/ecs/entity-handle"},"next":{"title":"System","permalink":"/docs/core-concepts/ecs/system"}}');var s=i(74848),r=i(28453);const c={title:"View",description:"Lightweight iterator for querying entities with specific components.",slug:"/core-concepts/ecs/view",sidebar_label:"View",sidebar_position:5,tags:["ecs","architecture","query"],keywords:["helios","View","ECS","component query","iteration"]},o="View",l={},a=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"API Reference",id:"api-reference",level:2},{value:"Construction",id:"construction",level:3},{value:"Filtering",id:"filtering",level:3},{value:"exclude<T>()",id:"exclude",level:4},{value:"whereEnabled()",id:"whereenabled",level:4},{value:"Iteration",id:"iteration",level:3},{value:"Usage Patterns",id:"usage-patterns",level:2},{value:"Basic Query",id:"basic-query",level:3},{value:"Multi-Component Query",id:"multi-component-query",level:3},{value:"With Active Tag",id:"with-active-tag",level:3},{value:"Exclusion",id:"exclusion",level:3},{value:"Chained Filters",id:"chained-filters",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Lead Set Selection",id:"lead-set-selection",level:3},{value:"Sparse Set Iteration",id:"sparse-set-iteration",level:3},{value:"Cross-Reference Cost",id:"cross-reference-cost",level:3},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Iterator Structure",id:"iterator-structure",level:3},{value:"Validity Checks",id:"validity-checks",level:3},{value:"Thread Safety",id:"thread-safety",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",t:"t",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"view",children:"View"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"View"})," provides lightweight, efficient iteration over entities that have specific components. It uses the sparse set architecture to achieve cache-friendly traversal without copying data."]}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Views enable component-based queries using a fluent API:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Iterate all entities with Transform and Velocity\nfor (auto [entity, transform, velocity] : gameWorld->view<\n    TransformComponent,\n    VelocityComponent\n>()) {\n    velocity->position += velocity->direction * deltaTime;\n}\n\n// With filters\nfor (auto [entity, health, active] : gameWorld->view<\n    HealthComponent,\n    Active\n>().whereEnabled().exclude<Invincible>()) {\n    // Process only enabled, non-invincible entities\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsxs)(n.p,{children:["The View uses the ",(0,s.jsx)(n.strong,{children:"lead set pattern"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:'The first component type becomes the "lead" iterator'}),"\n",(0,s.jsx)(n.li,{children:"For each entity in the lead set, check existence in other sets"}),"\n",(0,s.jsx)(n.li,{children:"Apply exclusion and filter predicates"}),"\n",(0,s.jsx)(n.li,{children:"Yield matching entities with their components"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Lead Set (Transform):     [E0, E2, E5, E7, E9]\n                           \u2193   \u2193   \u2193   \u2193   \u2193\nVelocity Set:             [E0, E2, __, E7, __]  \u2190 Cross-reference\n                           \u2713   \u2713   \u2717   \u2713   \u2717\n                           \nResult:                   [E0, E2, E7]\n"})}),"\n",(0,s.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,s.jsx)(n.h3,{id:"construction",children:"Construction"}),"\n",(0,s.jsxs)(n.p,{children:["Views are typically obtained from ",(0,s.jsx)(n.code,{children:"GameWorld"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto view = gameWorld->view<ComponentA, ComponentB, ComponentC>();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Or directly from ",(0,s.jsx)(n.code,{children:"EntityManager"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"View<ComponentA, ComponentB> view(&entityManager);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"filtering",children:"Filtering"}),"\n",(0,s.jsxs)(n.h4,{id:"exclude",children:["exclude",(0,s.jsx)(n.t,{children:"()"})]}),"\n",(0,s.jsx)(n.p,{children:"Excludes entities that have a specific component:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Skip entities with Shield component\nfor (auto [e, health] : world->view<HealthComponent>()\n    .exclude<ShieldComponent>()) {\n    // Only unshielded entities\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"whereenabled",children:"whereEnabled()"}),"\n",(0,s.jsx)(n.p,{children:"Filters to only include entities where all queried components are enabled:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"for (auto [e, move, active] : world->view<\n    Move2DComponent,\n    Active\n>().whereEnabled()) {\n    // Only if move.isEnabled() && active.isEnabled()\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Components without an ",(0,s.jsx)(n.code,{children:"isEnabled()"})," method are assumed enabled."]}),"\n",(0,s.jsx)(n.h3,{id:"iteration",children:"Iteration"}),"\n",(0,s.jsx)(n.p,{children:"Views support range-based for loops with structured bindings:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"for (auto [entity, compA, compB] : view) {\n    // entity: GameObject\n    // compA: ComponentA*\n    // compB: ComponentB*\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The tuple contains:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"GameObject"})," - wrapper for the entity"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Component*..."})," - pointers to each queried component"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"usage-patterns",children:"Usage Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"basic-query",children:"Basic Query"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"for (auto [entity, transform] : world->view<TransformComponent>()) {\n    transform->setPosition(newPos);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"multi-component-query",children:"Multi-Component Query"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"for (auto [entity, transform, velocity, gravity] : world->view<\n    TransformComponent,\n    VelocityComponent,\n    GravityComponent\n>()) {\n    velocity->velocity += gravity->force * deltaTime;\n    transform->position += velocity->velocity * deltaTime;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"with-active-tag",children:"With Active Tag"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Common pattern: include Active tag to skip inactive entities\nfor (auto [entity, health, damage, active] : world->view<\n    HealthComponent,\n    DamageDealerComponent,\n    Active\n>().whereEnabled()) {\n    // Process only active entities\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"exclusion",children:"Exclusion"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Find all enemies without AI (for debugging)\nfor (auto [entity, enemy] : world->view<EnemyComponent>()\n    .exclude<AIComponent>()) {\n    LOG_WARN("Enemy {} has no AI!", entity.entityHandle().entityId);\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"chained-filters",children:"Chained Filters"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"for (auto [e, h, a] : world->view<HealthComponent, Active>()\n    .whereEnabled()\n    .exclude<Invincible>()\n    .exclude<Dead>()) {\n    // Enabled, not invincible, not dead\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"lead-set-selection",children:"Lead Set Selection"}),"\n",(0,s.jsxs)(n.p,{children:["The first component type determines iteration order. Choose the ",(0,s.jsx)(n.strong,{children:"smallest set"})," as the lead for best performance:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// If few entities have RareComponent, put it first\nfor (auto [e, rare, common] : world->view<\n    RareComponent,    // Lead - smallest set\n    CommonComponent\n>()) { }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"sparse-set-iteration",children:"Sparse Set Iteration"}),"\n",(0,s.jsx)(n.p,{children:"Views iterate the dense storage of the lead set, which is:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cache-friendly"})," - contiguous memory access"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No indirection"})," - direct component access"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"O(n)"})," - linear in the number of entities with the lead component"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"cross-reference-cost",children:"Cross-Reference Cost"}),"\n",(0,s.jsx)(n.p,{children:"Each additional component type adds an O(1) existence check per entity. For views with many component types, this can add up."}),"\n",(0,s.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,s.jsx)(n.h3,{id:"iterator-structure",children:"Iterator Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct Iterator {\n    LeadIterator current_;  // Points into lead SparseSet\n    LeadIterator end_;\n    const View* view_;\n    \n    bool isValid() const;   // Check all predicates\n    void advance();         // Skip to next valid entity\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"validity-checks",children:"Validity Checks"}),"\n",(0,s.jsx)(n.p,{children:"For each entity, the iterator checks:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Entity validity"})," - Handle is still valid in registry"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Include check"})," - Entity has all required components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Exclude check"})," - Entity has none of the excluded components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Enabled check"})," - All components pass ",(0,s.jsx)(n.code,{children:"isEnabled()"})," (if filtered)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,s.jsxs)(n.p,{children:["Views are ",(0,s.jsx)(n.strong,{children:"not thread-safe"}),". The underlying EntityManager and SparseSets must not be modified during iteration."]}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/ecs/entity-manager",children:"EntityManager"})," - Component storage"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/sparse-set",children:"SparseSet"})," - Underlying data structure"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/ecs/gameobject",children:"GameObject"})," - Entity wrapper returned by views"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/ecs/system",children:"System"})," - Systems that use views for queries"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/ecs/traits",children:"Traits"})," - isEnabled() detection"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/component-lifecycle",children:"Component Lifecycle"})," - isEnabled() and other hooks"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);