"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[69914],{28453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>a});var t=s(96540);const r={},o=t.createContext(r);function i(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(o.Provider,{value:n},e.children)}},62362:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"core-concepts/sparse-set","title":"Sparse Set","description":"Generic O(1) data structure for efficient entity-component storage in the ECS.","source":"@site/docs/core-concepts/sparse-set.md","sourceDirName":"core-concepts","slug":"/core-concepts/sparse-set","permalink":"/docs/core-concepts/sparse-set","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/sparse-set.md","tags":[{"inline":true,"label":"ecs","permalink":"/docs/tags/ecs"},{"inline":true,"label":"architecture","permalink":"/docs/tags/architecture"},{"inline":true,"label":"data-structure","permalink":"/docs/tags/data-structure"}],"version":"current","sidebarPosition":11,"frontMatter":{"title":"Sparse Set","description":"Generic O(1) data structure for efficient entity-component storage in the ECS.","slug":"/core-concepts/sparse-set","sidebar_label":"Sparse Set","sidebar_position":11,"tags":["ecs","architecture","data-structure"],"keywords":["helios","sparse set","ECS","component storage","swap-and-pop","O(1)"]},"sidebar":"tutorialSidebar","previous":{"title":"ComponentOps","permalink":"/docs/core-concepts/ecs/component-ops"},"next":{"title":"Component Registry","permalink":"/docs/core-concepts/component-registry"}}');var r=s(74848),o=s(28453);const i={title:"Sparse Set",description:"Generic O(1) data structure for efficient entity-component storage in the ECS.",slug:"/core-concepts/sparse-set",sidebar_label:"Sparse Set",sidebar_position:11,tags:["ecs","architecture","data-structure"],keywords:["helios","sparse set","ECS","component storage","swap-and-pop","O(1)"]},a="Sparse Set",c={},l=[{value:"SparseSetBase",id:"sparsesetbase",level:2},{value:"Overview",id:"overview",level:2},{value:"Complexity",id:"complexity",level:2},{value:"Usage",id:"usage",level:2},{value:"Basic Operations",id:"basic-operations",level:3},{value:"Removal Interception with Traits",id:"removal-interception-with-traits",level:3},{value:"Swap-and-Pop Removal",id:"swap-and-pop-removal",level:2},{value:"Memory Considerations",id:"memory-considerations",level:2},{value:"Related Modules",id:"related-modules",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"sparse-set",children:"Sparse Set"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"SparseSet"})," is a generic data structure providing O(1) insertion, lookup, and removal operations. It is a fundamental building block for the helios ECS (Entity Component System), used internally for efficient component storage."]}),"\n",(0,r.jsx)(n.h2,{id:"sparsesetbase",children:"SparseSetBase"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"SparseSetBase"})," is an abstract base class providing a type-erased interface for sparse sets. This enables polymorphic access to heterogeneous component pools:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// EntityManager stores different component types uniformly\nstd::vector<std::unique_ptr<SparseSetBase>> components_;\n\n// Remove component without knowing the concrete type\ncomponents_[typeId]->remove(entityId);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"A sparse set maintains two arrays:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sparse array:"})," Maps entity indices to positions in the dense array"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dense array:"})," Stores actual data contiguously in memory"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This design enables:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"O(1) access"})," via direct indexing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"O(1) removal"})," via swap-and-pop"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cache-friendly iteration"})," over dense storage"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      SPARSE SET ARCHITECTURE                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                     \u2502\n\u2502  SPARSE ARRAY (indexed by EntityId)                                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502  \u2502  2  \u2502  \xd7  \u2502  0  \u2502  \xd7  \u2502  1  \u2502  \xd7  \u2502  \xd7  \u2502  (dense index)         \u2502\n\u2502  \u2514\u2500\u2500\u252c\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u252c\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u252c\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2502     \u2502           \u2502           \u2502                                       \u2502\n\u2502     \u2502           \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502     \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502                        \u2502\n\u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502         \u2502                        \u2502\n\u2502                            \u25bc     \u25bc         \u25bc                        \u2502\n\u2502  DENSE STORAGE (contiguous memory)                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                    \u2502\n\u2502  \u2502  T[0]   \u2502  T[1]   \u2502  T[2]   \u2502                                    \u2502\n\u2502  \u2502 (id=2)  \u2502 (id=4)  \u2502 (id=0)  \u2502                                    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                    \u2502\n\u2502                                                                     \u2502\n\u2502  DENSE-TO-SPARSE (reverse mapping for swap-and-pop)                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510                                                \u2502\n\u2502  \u2502  2  \u2502  4  \u2502  0  \u2502  (EntityId)                                    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518                                                \u2502\n\u2502                                                                     \u2502\n\u2502  \xd7 = Tombstone (empty slot)                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h2,{id:"complexity",children:"Complexity"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Operation"}),(0,r.jsx)(n.th,{children:"Time"}),(0,r.jsx)(n.th,{children:"Space"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"emplace"}),(0,r.jsx)(n.td,{children:"O(1)*"}),(0,r.jsx)(n.td,{children:"O(max_id)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"insert"}),(0,r.jsx)(n.td,{children:"O(1)*"}),(0,r.jsx)(n.td,{children:"O(max_id)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"get"}),(0,r.jsx)(n.td,{children:"O(1)"}),(0,r.jsx)(n.td,{children:"-"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"remove"}),(0,r.jsx)(n.td,{children:"O(1)"}),(0,r.jsx)(n.td,{children:"-"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"*Amortized due to potential sparse array resize."}),"\n",(0,r.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(n.h3,{id:"basic-operations",children:"Basic Operations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.ecs.SparseSet;\n\nusing namespace helios::engine::ecs;\n\n// Create a sparse set for transform components\nSparseSet<TransformComponent> transforms;\n\n// In-place construction with emplace (forwards arguments to T's constructor)\nauto* transform = transforms.emplace(42, glm::vec3{0.0f}, glm::quat{}, glm::vec3{1.0f});\n\n// Or insert a pre-constructed object (moved)\nTransformComponent tc{glm::vec3{1.0f}, glm::quat{}, glm::vec3{1.0f}};\nauto* inserted = transforms.insert(43, std::move(tc));\n\n// Mutable access\nif (auto* t = transforms.get(42)) {\n    t->position = glm::vec3{10.0f, 0.0f, 0.0f};\n}\n\n// Const access (read-only)\nconst auto& constTransforms = transforms;\nif (const auto* t = constTransforms.get(42)) {\n    // t->position = ...;  // Error: const pointer\n}\n\n// Remove component\ntransforms.remove(42);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"removal-interception-with-traits",children:"Removal Interception with Traits"}),"\n",(0,r.jsxs)(n.p,{children:["Components can intercept removal by implementing the ",(0,r.jsx)(n.code,{children:"HasOnRemove"})," trait. If the ",(0,r.jsx)(n.code,{children:"onRemove()"})," method returns ",(0,r.jsx)(n.code,{children:"false"}),", removal is cancelled."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.ecs.Traits;\n\n// Component with removal interception\nstruct ResourceComponent {\n    bool inUse = false;\n\n    // Trait implementation: return false to cancel removal\n    bool onRemove() {\n        if (inUse) {\n            return false;  // Cancel removal while in use\n        }\n        releaseResources();\n        return true;  // Allow removal\n    }\n\n    void releaseResources() { /* ... */ }\n};\n\n// Verify trait is satisfied\nstatic_assert(helios::engine::ecs::traits::HasOnRemove<ResourceComponent>);\n\n// Usage\nSparseSet<ResourceComponent> resources;\nresources.emplace(42);\n\n// Removal will call onRemove() at compile-time if trait is satisfied\nresources.remove(42);  // Calls component.onRemove() before removal\n"})}),"\n",(0,r.jsx)(n.h2,{id:"swap-and-pop-removal",children:"Swap-and-Pop Removal"}),"\n",(0,r.jsxs)(n.p,{children:["When removing an element, the sparse set uses the ",(0,r.jsx)(n.strong,{children:"swap-and-pop"})," technique to maintain dense storage contiguity:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Move the last element to the position of the removed element"}),"\n",(0,r.jsx)(n.li,{children:"Update the sparse array entry for the moved element"}),"\n",(0,r.jsx)(n.li,{children:"Pop the last element from dense storage"}),"\n",(0,r.jsxs)(n.li,{children:["Mark the removed slot as ",(0,r.jsx)(n.code,{children:"Tombstone"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This avoids expensive array shifts and maintains O(1) removal."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Before removing entity 2 (at dense index 1):\n\n         EntityId:  0     1     2     3\nSparse:           [ 0  |  \xd7  |  1  |  2  ]     (EntityId \u2192 Dense Index)\n                    \u2502         \u2502     \u2502\n                    \u2502    \u250c\u2500\u2500\u2500\u2500\u2518     \u2502\n                    \u2502    \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u25bc    \u25bc    \u25bc\nDense:            [ A  |  B  |  C  ]           (Contiguous storage)\n                    0     1     2              (Dense Index)\n\nDenseToSparse:    [ 0  |  2  |  3  ]           (Dense Index \u2192 EntityId)\n\n\xd7 = Tombstone (empty slot)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nAfter removing entity 2 (swap C into position 1, pop):\n\n         EntityId:  0     1     2     3\nSparse:           [ 0  |  \xd7  |  \xd7  |  1  ]     Entity 3 now at dense index 1\n                    \u2502               \u2502\n                    \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u25bc    \u25bc\nDense:            [ A  |  C  ]                 B removed, C moved\n                    0     1\n\nDenseToSparse:    [ 0  |  3  ]                 Position 1 now holds entity 3\n"})}),"\n",(0,r.jsx)(n.h2,{id:"memory-considerations",children:"Memory Considerations"}),"\n",(0,r.jsx)(n.p,{children:"The sparse array grows to accommodate the maximum EntityId used. For applications with large, sparse entity ID ranges, this may result in significant memory usage. Consider:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compact entity IDs:"})," Use entity recycling to keep IDs within a reasonable range"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Paged sparse arrays:"})," For very large ID ranges, a paged implementation can reduce memory overhead"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"related-modules",children:"Related Modules"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"helios.engine.core.data.EntityId"})," \u2014 Entity identifier type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"helios.engine.core.data.EntityTombstone"})," \u2014 Sentinel value for empty slots"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"helios.engine.core.data.EntityHandle"})," \u2014 Versioned entity reference"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/core-concepts/ecs/entity-manager",children:"EntityManager"})," - Uses SparseSet for component storage"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/core-concepts/ecs/gameobject",children:"GameObject"})," - High-level entity wrapper"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/core-concepts/component-system",children:"Component System"})," - ECS component architecture"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/core-concepts/component-lifecycle",children:"Component Lifecycle"})," - Lifecycle hooks including onRemove"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);