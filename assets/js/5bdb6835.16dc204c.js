"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[14438],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var t=s(96540);const i={},o=t.createContext(i);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:n},e.children)}},56178:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"core-concepts/component-system","title":"Component System","description":"Composition-based entity design with Components, Systems, and GameWorld for flexible game logic.","source":"@site/docs/core-concepts/component-system.md","sourceDirName":"core-concepts","slug":"/core-concepts/component-system","permalink":"/docs/core-concepts/component-system","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/component-system.md","tags":[{"inline":true,"label":"gameplay","permalink":"/docs/tags/gameplay"},{"inline":true,"label":"architecture","permalink":"/docs/tags/architecture"}],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Component System","description":"Composition-based entity design with Components, Systems, and GameWorld for flexible game logic.","slug":"/core-concepts/component-system","sidebar_label":"Component System","sidebar_position":3,"tags":["gameplay","architecture"],"keywords":["helios","component","system","GameObject","GameWorld","composition"]},"sidebar":"tutorialSidebar","previous":{"title":"Scene Graph","permalink":"/docs/core-concepts/scene-graph"},"next":{"title":"Game Loop","permalink":"/docs/core-concepts/gameloop-architecture"}}');var i=s(74848),o=s(28453);const r={title:"Component System",description:"Composition-based entity design with Components, Systems, and GameWorld for flexible game logic.",slug:"/core-concepts/component-system",sidebar_label:"Component System",sidebar_position:3,tags:["gameplay","architecture"],keywords:["helios","component","system","GameObject","GameWorld","composition"]},l="Component System",c={},d=[{value:"Overview",id:"overview",level:2},{value:"Key Classes",id:"key-classes",level:2},{value:"Components",id:"components",level:3},{value:"Component Enabled State",id:"component-enabled-state",level:4},{value:"<code>GameObject</code>",id:"gameobject",level:3},{value:"Component Storage",id:"component-storage",level:4},{value:"<code>System</code>",id:"system",level:3},{value:"<code>GameWorld</code>",id:"gameworld",level:3},{value:"<code>GameLoop</code>",id:"gameloop",level:3},{value:"Built-in Components",id:"built-in-components",level:2},{value:"Spatial/Transform",id:"spatialtransform",level:3},{value:"Physics/Motion",id:"physicsmotion",level:3},{value:"Physics/Collision",id:"physicscollision",level:3},{value:"Gameplay",id:"gameplay",level:3},{value:"Spawn/Pool",id:"spawnpool",level:3},{value:"Scene",id:"scene",level:3},{value:"Input",id:"input",level:3},{value:"Built-in Systems",id:"built-in-systems",level:2},{value:"Pre Phase Systems",id:"pre-phase-systems",level:3},{value:"Main Phase Systems",id:"main-phase-systems",level:3},{value:"Post Phase Systems",id:"post-phase-systems",level:3},{value:"Creating Custom Components",id:"creating-custom-components",level:2},{value:"Creating Custom Systems",id:"creating-custom-systems",level:2},{value:"Querying GameObjects",id:"querying-gameobjects",level:2},{value:"GameObjectFilter",id:"gameobjectfilter",level:3},{value:"Filtering Examples",id:"filtering-examples",level:3},{value:"Update Order",id:"update-order",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function a(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"component-system",children:"Component System"})}),"\n",(0,i.jsxs)(n.p,{children:["helios implements a ",(0,i.jsx)(n.strong,{children:"composition-based component architecture"})," that separates data from behavior, enabling flexible and reusable game logic without deep inheritance hierarchies."]}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:'The component system follows the "composition over inheritance" principle:'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Components"})," store data for entities (plain data classes, no base class required)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Systems"})," operate on groups of entities with specific component configurations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"GameWorld"})," manages entity lifecycle via EntityRegistry and EntityManager"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"GameLoop"})," orchestrates Systems across Phases and Passes"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This design allows you to build complex entities by mixing and matching components rather than creating specialized subclasses."}),"\n",(0,i.jsx)(n.h2,{id:"key-classes",children:"Key Classes"}),"\n",(0,i.jsx)(n.h3,{id:"components",children:"Components"}),"\n",(0,i.jsxs)(n.p,{children:["Components are ",(0,i.jsx)(n.strong,{children:"plain data classes"})," \u2014 they store state but should not contain complex update logic. Unlike traditional ECS frameworks, helios components do ",(0,i.jsx)(n.strong,{children:"not"})," inherit from a base class."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"class HealthComponent {\n    float health_ = 100.0f;\n    float maxHealth_ = 100.0f;\n    bool isEnabled_ = true;\n\npublic:\n    // Required: Copy and Move constructors\n    HealthComponent(const HealthComponent&) = default;\n    HealthComponent(HealthComponent&&) noexcept = default;\n\n    // Optional: Enable/Disable for view filtering\n    [[nodiscard]] bool isEnabled() const noexcept { return isEnabled_; }\n    void enable() noexcept { isEnabled_ = true; }\n    void disable() noexcept { isEnabled_ = false; }\n\n    // Business logic\n    void takeDamage(float amount) { health_ -= amount; }\n    [[nodiscard]] float health() const { return health_; }\n};\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," Components must have a ",(0,i.jsx)(n.code,{children:"noexcept"})," move constructor for efficient storage in SparseSets. See ",(0,i.jsx)(n.a,{href:"/docs/core-concepts/ecs/component-structure",children:"Component Structure"})," for full requirements."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"component-enabled-state",children:"Component Enabled State"}),"\n",(0,i.jsxs)(n.p,{children:["Components can implement ",(0,i.jsx)(n.code,{children:"isEnabled()"})," / ",(0,i.jsx)(n.code,{children:"enable()"})," / ",(0,i.jsx)(n.code,{children:"disable()"})," for view filtering:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"[[nodiscard]] bool isEnabled() const noexcept;\nvoid enable() noexcept;\nvoid disable() noexcept;\n"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"State"}),(0,i.jsx)(n.th,{children:"Meaning"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"isEnabled() == true"})}),(0,i.jsx)(n.td,{children:"Component is active and included in filtered views"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"isEnabled() == false"})}),(0,i.jsxs)(n.td,{children:["Component is skipped by ",(0,i.jsx)(n.code,{children:".whereEnabled()"})," but remains attached"]})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["This allows fine-grained control over individual components. For example, temporarily disabling a ",(0,i.jsx)(n.code,{children:"CollisionComponent"})," makes an entity pass through walls."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Important:"})," Disabling a component does ",(0,i.jsx)(n.strong,{children:"not"})," deactivate the entire entity. Use ",(0,i.jsx)(n.code,{children:"GameObject::setActive(false)"})," to exclude an entity from all processing."]}),"\n",(0,i.jsx)(n.h3,{id:"gameobject",children:(0,i.jsx)(n.code,{children:"GameObject"})}),"\n",(0,i.jsx)(n.p,{children:"A lightweight wrapper (~16 bytes) for entity manipulation. Pass by value, not by reference."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Create entity via GameWorld\nauto entity = gameWorld.addGameObject();\n\n// Add components\nentity.add<SceneNodeComponent>(sceneNode);\nentity.add<Move2DComponent>(speed);\nentity.add<HealthComponent>(100.0f);\n\n// Retrieve components by type (O(1) lookup)\nauto* health = entity.get<HealthComponent>();\n\n// Check component presence\nif (entity.has<CollisionComponent>()) {\n    // ...\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Each entity is identified by a versioned ",(0,i.jsx)(n.code,{children:"EntityHandle"})," for safe reference tracking."]}),"\n",(0,i.jsx)(n.h4,{id:"component-storage",children:"Component Storage"}),"\n",(0,i.jsxs)(n.p,{children:["Components are stored in type-specific ",(0,i.jsx)(n.code,{children:"SparseSet<T>"})," containers managed by ",(0,i.jsx)(n.code,{children:"EntityManager"}),". This provides ",(0,i.jsx)(n.strong,{children:"O(1) access"}),":"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Operation"}),(0,i.jsx)(n.th,{children:"Complexity"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"get<T>()"})}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"Direct SparseSet lookup via type ID"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"has<T>()"})}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"SparseSet contains check"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"add<T>()"})}),(0,i.jsx)(n.td,{children:"O(1) amortized"}),(0,i.jsx)(n.td,{children:"SparseSet emplace"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"system",children:(0,i.jsx)(n.code,{children:"System"})}),"\n",(0,i.jsxs)(n.p,{children:["Global logic processors that operate on the entire GameWorld. Systems are registered with the ",(0,i.jsx)(n.strong,{children:"GameLoop"})," and executed within Phases and Passes."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.ecs.System;\n\nclass PhysicsSystem : public helios::engine::ecs::System {\npublic:\n    void update(UpdateContext& ctx) noexcept override {\n        // Iterate all active entities with required components\n        for (auto [entity, move, transform, active] : gameWorld_->view<\n            Move2DComponent,\n            TranslationStateComponent,\n            Active\n        >().whereEnabled()) {\n            // Apply physics simulation...\n            transform->translateBy(move->velocity() * ctx.deltaTime());\n        }\n    }\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Systems are organized into Phases (Pre, Main, Post) and Passes within each Phase. See ",(0,i.jsx)(n.a,{href:"/docs/core-concepts/gameloop-architecture",children:"Game Loop Architecture"})," for details."]}),"\n",(0,i.jsx)(n.h3,{id:"gameworld",children:(0,i.jsx)(n.code,{children:"GameWorld"})}),"\n",(0,i.jsxs)(n.p,{children:["The root container managing entities, Managers, and Pools. Located in ",(0,i.jsx)(n.code,{children:"helios::engine::runtime::world"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.runtime.world.GameWorld;\n\nhelios::engine::runtime::world::GameWorld world;\n\n// Create entities\nauto player = world.addGameObject();\nplayer.add<Move2DComponent>(speed);\n\n// Add managers for deferred processing\nworld.addManager<SpawnManager>();\n\n// Query entities by component using views\nfor (auto [entity, move, collision] : world.view<\n    Move2DComponent,\n    CollisionComponent\n>()) {\n    // Process matching entities\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"gameloop",children:(0,i.jsx)(n.code,{children:"GameLoop"})}),"\n",(0,i.jsxs)(n.p,{children:["The orchestrator for system execution, located in ",(0,i.jsx)(n.code,{children:"helios::engine::runtime::gameloop"}),". Systems are added to Phases and Passes:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.runtime.gameloop.GameLoop;\n\nhelios::engine::runtime::gameloop::GameLoop gameLoop;\n\n// Pre Phase: Input processing\ngameLoop.phase(PhaseType::Pre)\n    .addPass()\n    .addSystem<InputSystem>(gameWorld);\n\n// Main Phase: Gameplay logic\ngameLoop.phase(PhaseType::Main)\n    .addPass()\n    .addSystem<Move2DSystem>(gameWorld)\n    .addSystem<CollisionSystem>(gameWorld);\n\n// Post Phase: Synchronization\ngameLoop.phase(PhaseType::Post)\n    .addPass()\n    .addSystem<SceneSyncSystem>(gameWorld, scene);\n\n// Initialize and run\ngameLoop.init(gameWorld);\ngameLoop.update(gameWorld, deltaTime, inputSnapshot);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"built-in-components",children:"Built-in Components"}),"\n",(0,i.jsx)(n.p,{children:"helios provides several ready-to-use components organized by domain:"}),"\n",(0,i.jsx)(n.h3,{id:"spatialtransform",children:"Spatial/Transform"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Component"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ComposeTransformComponent"})}),(0,i.jsx)(n.td,{children:"Stores local transform with dirty tracking"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ScaleStateComponent"})}),(0,i.jsx)(n.td,{children:"Unit-based sizing using helios units (meters)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"TranslationStateComponent"})}),(0,i.jsx)(n.td,{children:"Translation delta for frame-based movement"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"physicsmotion",children:"Physics/Motion"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Component"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Move2DComponent"})}),(0,i.jsx)(n.td,{children:"2D movement parameters (max speed, acceleration, dampening)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"HeadingComponent"})}),(0,i.jsx)(n.td,{children:"Rotation state and target angle"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"DirectionComponent"})}),(0,i.jsx)(n.td,{children:"Normalized movement direction"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"SpinComponent"})}),(0,i.jsx)(n.td,{children:"Continuous rotation (spin speed)"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"physicscollision",children:"Physics/Collision"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Component"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"AabbColliderComponent"})}),(0,i.jsx)(n.td,{children:"Axis-aligned bounding box for collision"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"CollisionComponent"})}),(0,i.jsx)(n.td,{children:"Collision configuration (layer, mask, response type)"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"gameplay",children:"Gameplay"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Component"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"LevelBoundsBehaviorComponent"})}),(0,i.jsx)(n.td,{children:"Arena boundary interaction (bounce, clamp, wrap, despawn)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ShootComponent"})}),(0,i.jsx)(n.td,{children:"Projectile firing with cooldown timer"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Aim2DComponent"})}),(0,i.jsx)(n.td,{children:"Aiming direction for twin-stick controls"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"spawnpool",children:"Spawn/Pool"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Component"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"SpawnedByProfileComponent"})}),(0,i.jsx)(n.td,{children:"Tracks which spawn profile created this entity"})]})})]}),"\n",(0,i.jsx)(n.h3,{id:"scene",children:"Scene"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Component"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"SceneNodeComponent"})}),(0,i.jsx)(n.td,{children:"Links a GameObject to a scene graph node"})]})})]}),"\n",(0,i.jsx)(n.h3,{id:"input",children:"Input"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Component"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"TwinStickInputComponent"})}),(0,i.jsx)(n.td,{children:"Dual analog stick input mapping"})]})})]}),"\n",(0,i.jsx)(n.h2,{id:"built-in-systems",children:"Built-in Systems"}),"\n",(0,i.jsx)(n.p,{children:"Systems are organized by their typical Phase placement:"}),"\n",(0,i.jsx)(n.h3,{id:"pre-phase-systems",children:"Pre Phase Systems"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"System"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Input processing systems"}),(0,i.jsx)(n.td,{children:"Read input, generate Commands"})]})})]}),"\n",(0,i.jsx)(n.h3,{id:"main-phase-systems",children:"Main Phase Systems"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"System"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Move2DSystem"})}),(0,i.jsx)(n.td,{children:"Applies velocity/acceleration to ComposeTransformComponent"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"HeadingSystem"})}),(0,i.jsx)(n.td,{children:"Smoothly rotates entities toward target angle"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"SpinSystem"})}),(0,i.jsx)(n.td,{children:"Applies continuous rotation"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"BoundsUpdateSystem"})}),(0,i.jsx)(n.td,{children:"Updates AABB colliders from transforms"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"GridCollisionDetectionSystem"})}),(0,i.jsx)(n.td,{children:"Spatial partitioning collision detection"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"LevelBoundsBehaviorSystem"})}),(0,i.jsx)(n.td,{children:"Handles boundary collision behaviors"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ComposeTransformSystem"})}),(0,i.jsx)(n.td,{children:"Composes transform from translation/rotation/scale"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ScaleSystem"})}),(0,i.jsx)(n.td,{children:"Applies scale changes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"GameObjectSpawnSystem"})}),(0,i.jsx)(n.td,{children:"Evaluates spawn rules, creates spawn commands"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ProjectileSpawnSystem"})}),(0,i.jsx)(n.td,{children:"Handles projectile spawning from shoot commands"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"post-phase-systems",children:"Post Phase Systems"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"System"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"SceneSyncSystem"})}),(0,i.jsx)(n.td,{children:"Syncs transforms from gameplay to scene graph"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"TransformClearSystem"})}),(0,i.jsx)(n.td,{children:"Clears dirty flags after frame"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"creating-custom-components",children:"Creating Custom Components"}),"\n",(0,i.jsxs)(n.p,{children:["Define a class inheriting from ",(0,i.jsx)(n.code,{children:"Component"}),". Components should be placed in your project's modules namespace:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"export module myproject.components.Inventory;\n\nimport helios.engine.ecs.Component;\n\nexport class InventoryComponent : public helios::engine::ecs::Component {\n    std::vector<Item> items_;\n    \npublic:\n    void addItem(Item item) { items_.push_back(std::move(item)); }\n    const std::vector<Item>& items() const { return items_; }\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For components that need cloning (e.g., for object pools), implement ",(0,i.jsx)(n.code,{children:"CloneableComponent"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"\n\nclass HealthComponent : public helios::engine::ecs::CloneableComponent {\n    int maxHealth_ = 100;\n    int currentHealth_ = 100;\n    \npublic:\n    std::unique_ptr<Component> clone() const override {\n        auto copy = std::make_unique<HealthComponent>();\n        copy->maxHealth_ = maxHealth_;\n        copy->currentHealth_ = maxHealth_;  // Reset to max on clone\n        return copy;\n    }\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"creating-custom-systems",children:"Creating Custom Systems"}),"\n",(0,i.jsxs)(n.p,{children:["Define a class inheriting from ",(0,i.jsx)(n.code,{children:"System"}),". Systems are registered with the GameLoop and operate on the GameWorld:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"export module myproject.systems.Spawner;\n\nimport helios.engine.ecs.System;\nimport helios.engine.runtime.world.GameWorld;\n\nexport class SpawnerSystem : public helios::engine::ecs::System {\n    float timer_ = 0.0f;\n    \npublic:\n    explicit SpawnerSystem(helios::engine::runtime::world::GameWorld& world) \n        : System(world) {}\n    \n    void update(helios::engine::runtime::world::UpdateContext& ctx) noexcept override {\n        timer_ += ctx.deltaTime();\n        if (timer_ > 5.0f) {\n            timer_ = 0.0f;\n            // Queue spawn via CommandBuffer\n            ctx.commandBuffer().add<SpawnCommand>(position, enemyType);\n        }\n    }\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"querying-gameobjects",children:"Querying GameObjects"}),"\n",(0,i.jsx)(n.p,{children:"GameWorld provides efficient component-based queries:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Find all GameObjects with specific components\nfor (auto* obj : gameWorld.find<Move2DComponent, SceneNodeComponent>()) {\n    // obj has both components\n}\n\n// Using structured bindings for direct component access\nfor (auto [obj, move, node] : gameWorld.find<Move2DComponent, SceneNodeComponent>().each()) {\n    // move and node are references to the components\n}\n\n// Filter by active state\nfor (auto* obj : gameWorld.find<HealthComponent>(GameObjectFilter::Active)) {\n    // Only active GameObjects\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"gameobjectfilter",children:"GameObjectFilter"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"GameObjectFilter"})," enum controls which GameObjects are included in query results:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.ecs.query.GameObjectFilter;\n\nusing helios::engine::ecs::query::GameObjectFilter;\n"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Filter"}),(0,i.jsx)(n.th,{children:"Meaning"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"GameObjectFilter::None"})}),(0,i.jsx)(n.td,{children:"No filtering (default)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"GameObjectFilter::Active"})}),(0,i.jsxs)(n.td,{children:["Only ",(0,i.jsx)(n.code,{children:"obj->isActive() == true"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"GameObjectFilter::Inactive"})}),(0,i.jsxs)(n.td,{children:["Only ",(0,i.jsx)(n.code,{children:"obj->isActive() == false"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"GameObjectFilter::ComponentEnabled"})}),(0,i.jsx)(n.td,{children:"Only objects with enabled queried components"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"GameObjectFilter::ComponentDisabled"})}),(0,i.jsx)(n.td,{children:"Only objects with disabled queried components"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"GameObjectFilter::All"})}),(0,i.jsx)(n.td,{children:"All GameObjects regardless of state"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Filters can be combined using bitwise OR:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Find inactive objects with disabled components\nauto filter = GameObjectFilter::Inactive | GameObjectFilter::ComponentDisabled;\nfor (auto* obj : gameWorld.find<CollisionComponent>(filter)) {\n    // Process matching objects\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"filtering-examples",children:"Filtering Examples"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Active GameObjects with enabled components:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"void update(UpdateContext& ctx) noexcept override {\n    auto filter = GameObjectFilter::Active | GameObjectFilter::ComponentEnabled;\n    \n    for (auto [obj, move, collision] : gameWorld_->find<Move2DComponent, CollisionComponent>(filter).each()) {\n        // Both GameObject is active AND components are enabled\n        // No manual checks required\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Manual filtering (alternative approach):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"void update(UpdateContext& ctx) noexcept override {\n    for (auto [obj, move, collision] : gameWorld_->find<Move2DComponent, CollisionComponent>().each()) {\n        \n        // Skip inactive GameObjects\n        if (!obj->isActive()) {\n            continue;\n        }\n        \n        // Skip disabled components\n        if (collision.isDisabled()) {\n            continue;  // Movement still applies, but no collision\n        }\n        \n        // Process with collision enabled...\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Finding disabled components (e.g., for re-enabling):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Find objects where invulnerability expired\nfor (auto [obj, invuln] : gameWorld_->find<InvulnerabilityComponent>(\n        GameObjectFilter::Active | GameObjectFilter::ComponentDisabled).each()) {\n    // Re-enable collision after invulnerability ends\n    obj->get<CollisionComponent>()->enable();\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"update-order",children:"Update Order"}),"\n",(0,i.jsx)(n.p,{children:"The GameLoop executes updates in three phases:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                          FRAME                                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                 \u2502\n\u2502  PRE PHASE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500   \u2502\n\u2502    Pass 1: Input systems                                        \u2502\n\u2502    [Phase Commit: Commands flush, Managers process]             \u2502\n\u2502                                                                 \u2502\n\u2502  MAIN PHASE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500   \u2502\n\u2502    Pass 1: Movement, Physics                                    \u2502\n\u2502    Pass 2: Collision Detection                                  \u2502\n\u2502    Pass 3: Gameplay Systems                                     \u2502\n\u2502    [Phase Commit: Commands flush, Managers process]             \u2502\n\u2502                                                                 \u2502\n\u2502  POST PHASE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500   \u2502\n\u2502    Pass 1: Scene Sync                                           \u2502\n\u2502    Pass 2: Cleanup (clear dirty flags)                          \u2502\n\u2502    [Phase Commit: Commands flush, Managers process]             \u2502\n\u2502                                                                 \u2502\n\u2502                        RENDER                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"/docs/core-concepts/gameloop-architecture",children:"Game Loop Architecture"})," for detailed phase/pass event handling."]}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Keep Components as Data Containers:"})," Components should store state, not complex logic. Move update logic to Systems."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Systems for Cross-Cutting Concerns:"})," Physics simulation, collision detection, and scene synchronization belong in Systems."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Prefer Composition:"})," Configure entities by attaching different component combinations rather than creating specialized subclasses."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Instead of: class Player : public GameObject { ... }\n\n// Do this:\nauto player = std::make_unique<GameObject>();\nplayer->add<SceneNodeComponent>(node);\nplayer->add<Move2DComponent>();\nplayer->add<HeadingComponent>();\nplayer->add<HealthComponent>();\nplayer->add<TwinStickInputComponent>();\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Commands for State Mutations:"})," Instead of mutating state directly in Systems, emit Commands to the CommandBuffer for deterministic execution."]}),"\n",(0,i.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/core-concepts/gameloop-architecture",children:"Game Loop Architecture"})," \u2014 Phase/Pass structure, commit points"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/core-concepts/command-system",children:"Command System"})," \u2014 Deferred action execution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/core-concepts/event-system",children:"Event System"})," \u2014 Phase/pass event propagation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/core-concepts/spawn-system",children:"Spawn System"})," \u2014 Entity lifecycle and object pooling"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}}}]);