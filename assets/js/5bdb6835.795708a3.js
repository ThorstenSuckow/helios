"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[14438],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var s=t(96540);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},33797:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"core-concepts/component-system","title":"Component System","description":"Composition-based entity design with Components, Systems, and GameWorld for flexible game logic.","source":"@site/docs/core-concepts/component-system.md","sourceDirName":"core-concepts","slug":"/core-concepts/component-system","permalink":"/docs/core-concepts/component-system","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/component-system.md","tags":[{"inline":true,"label":"gameplay","permalink":"/docs/tags/gameplay"},{"inline":true,"label":"architecture","permalink":"/docs/tags/architecture"}],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Component System","description":"Composition-based entity design with Components, Systems, and GameWorld for flexible game logic.","slug":"/core-concepts/component-system","sidebar_label":"Component System","sidebar_position":3,"tags":["gameplay","architecture"],"keywords":["helios","component","system","GameObject","GameWorld","composition"]},"sidebar":"tutorialSidebar","previous":{"title":"Conventions","permalink":"/docs/core-concepts/conventions"},"next":{"title":"Game Loop","permalink":"/docs/core-concepts/gameloop-architecture"}}');var o=t(74848),i=t(28453);const r={title:"Component System",description:"Composition-based entity design with Components, Systems, and GameWorld for flexible game logic.",slug:"/core-concepts/component-system",sidebar_label:"Component System",sidebar_position:3,tags:["gameplay","architecture"],keywords:["helios","component","system","GameObject","GameWorld","composition"]},c="Component System",d={},l=[{value:"Overview",id:"overview",level:2},{value:"Key Classes",id:"key-classes",level:2},{value:"<code>Component</code>",id:"component",level:3},{value:"<code>GameObject</code>",id:"gameobject",level:3},{value:"<code>System</code>",id:"system",level:3},{value:"<code>GameWorld</code>",id:"gameworld",level:3},{value:"Built-in Components",id:"built-in-components",level:2},{value:"Built-in Systems",id:"built-in-systems",level:2},{value:"Creating Custom Components",id:"creating-custom-components",level:2},{value:"Creating Custom Systems",id:"creating-custom-systems",level:2},{value:"Update Order",id:"update-order",level:2},{value:"Best Practices",id:"best-practices",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"component-system",children:"Component System"})}),"\n",(0,o.jsxs)(n.p,{children:["helios implements a ",(0,o.jsx)(n.strong,{children:"composition-based component architecture"})," that separates data from behavior, enabling flexible and reusable game logic without deep inheritance hierarchies."]}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(n.p,{children:'The component system follows the "composition over inheritance" principle:'}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Components"})," store data and optional behavior for GameObjects"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Systems"})," operate on groups of GameObjects with specific component configurations"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"GameWorld"})," manages the lifecycle of GameObjects and Systems"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This design allows you to build complex entities by mixing and matching components rather than creating specialized subclasses."}),"\n",(0,o.jsx)(n.h2,{id:"key-classes",children:"Key Classes"}),"\n",(0,o.jsx)(n.h3,{id:"component",children:(0,o.jsx)(n.code,{children:"Component"})}),"\n",(0,o.jsx)(n.p,{children:"The base class for all components attached to a GameObject."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.game.Component;\n\nclass HealthComponent : public helios::engine::game::Component {\n    int health_ = 100;\npublic:\n    void takeDamage(int amount) { health_ -= amount; }\n    int health() const { return health_; }\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Components receive a back-reference to their owning GameObject via ",(0,o.jsx)(n.code,{children:"onAttach()"}),", allowing them to interact with sibling components or the entity as a whole."]}),"\n",(0,o.jsx)(n.h3,{id:"gameobject",children:(0,o.jsx)(n.code,{children:"GameObject"})}),"\n",(0,o.jsx)(n.p,{children:"A container for components that represents an entity in the game world."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.game.GameObject;\n\nauto entity = std::make_unique<helios::engine::game::GameObject>();\n\n// Add components to define behavior\nentity->add<SceneNodeComponent>(sceneNode);\nentity->add<Move2DComponent>();\nentity->add<HealthComponent>();\n\n// Retrieve components by type\nauto* health = entity->get<HealthComponent>();\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Each GameObject has a unique ",(0,o.jsx)(n.code,{children:"Guid"})," for identification and supports per-frame updates for components implementing the ",(0,o.jsx)(n.code,{children:"Updatable"})," interface."]}),"\n",(0,o.jsx)(n.h3,{id:"system",children:(0,o.jsx)(n.code,{children:"System"})}),"\n",(0,o.jsx)(n.p,{children:"Global logic processors that operate on the entire GameWorld."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.game.System;\n\nclass PhysicsSystem : public helios::engine::game::System {\npublic:\n    void update(UpdateContext& ctx) noexcept override {\n        // Iterate all GameObjects with Move2DComponent\n        for (auto* obj : gameWorld_->find<Move2DComponent>()) {\n            auto* move = obj->get<Move2DComponent>();\n            auto* node = obj->get<SceneNodeComponent>();\n            // Apply physics simulation...\n        }\n    }\n};\n"})}),"\n",(0,o.jsx)(n.p,{children:"Systems are registered with the GameWorld and executed each frame after individual component updates."}),"\n",(0,o.jsx)(n.h3,{id:"gameworld",children:(0,o.jsx)(n.code,{children:"GameWorld"})}),"\n",(0,o.jsx)(n.p,{children:"The root container managing GameObjects, Systems, and the active Level."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.game.GameWorld;\n\nhelios::engine::game::GameWorld world;\n\n// Add entities\nauto* player = world.addGameObject(std::move(playerEntity));\n\n// Add systems\nworld.add<Move2DSystem>();\nworld.add<SceneSyncSystem>(scene.get());\nworld.add<BoundsUpdateSystem>();\n\n// Update each frame\nworld.update(ctx);\n"})}),"\n",(0,o.jsx)(n.h2,{id:"built-in-components",children:"Built-in Components"}),"\n",(0,o.jsx)(n.p,{children:"helios provides several ready-to-use components:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Component"}),(0,o.jsx)(n.th,{children:"Purpose"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"SceneNodeComponent"})}),(0,o.jsx)(n.td,{children:"Links a GameObject to a scene graph node"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Move2DComponent"})}),(0,o.jsx)(n.td,{children:"2D physics state (velocity, acceleration, rotation)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"TransformComponent"})}),(0,o.jsx)(n.td,{children:"Stores local and world transform matrices"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"ScaleComponent"})}),(0,o.jsx)(n.td,{children:"Unit-based sizing using helios units (meters)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"TwinStickInputComponent"})}),(0,o.jsx)(n.td,{children:"Dual analog stick input handling"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"ShootComponent"})}),(0,o.jsx)(n.td,{children:"Projectile firing with cooldown timer"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"AabbColliderComponent"})}),(0,o.jsx)(n.td,{children:"Axis-aligned bounding box for collision"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"LevelBoundsBehaviorComponent"})}),(0,o.jsx)(n.td,{children:"Arena boundary interaction (bounce, clamp, wrap)"})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"built-in-systems",children:"Built-in Systems"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"System"}),(0,o.jsx)(n.th,{children:"Purpose"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Move2DSystem"})}),(0,o.jsx)(n.td,{children:"Physics simulation (velocity, rotation)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"SceneSyncSystem"})}),(0,o.jsx)(n.td,{children:"Syncs transforms from gameplay to scene graph"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"ScaleSystem"})}),(0,o.jsx)(n.td,{children:"Applies ScaleComponent sizing"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"BoundsUpdateSystem"})}),(0,o.jsx)(n.td,{children:"Updates AABB colliders from transforms"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"LevelBoundsBehaviorSystem"})}),(0,o.jsx)(n.td,{children:"Handles boundary collision behaviors"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"ProjectilePoolSystem"})}),(0,o.jsx)(n.td,{children:"Object pool for projectile management"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"TransformClearSystem"})}),(0,o.jsx)(n.td,{children:"Clears dirty flags after frame"})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"creating-custom-components",children:"Creating Custom Components"}),"\n",(0,o.jsxs)(n.p,{children:["Define a class inheriting from ",(0,o.jsx)(n.code,{children:"Component"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"export module myproject.components.Inventory;\n\nimport helios.engine.game.Component;\n\nexport class InventoryComponent : public helios::engine::game::Component {\n    std::vector<Item> items_;\n    \npublic:\n    void addItem(Item item) { items_.push_back(std::move(item)); }\n    const std::vector<Item>& items() const { return items_; }\n};\n"})}),"\n",(0,o.jsx)(n.h2,{id:"creating-custom-systems",children:"Creating Custom Systems"}),"\n",(0,o.jsxs)(n.p,{children:["Define a class inheriting from ",(0,o.jsx)(n.code,{children:"System"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"export module myproject.systems.Spawner;\n\nimport helios.engine.game.System;\n\nexport class SpawnerSystem : public helios::engine::game::System {\n    float timer_ = 0.0f;\n    \npublic:\n    void update(UpdateContext& ctx) noexcept override {\n        timer_ += ctx.deltaTime();\n        if (timer_ > 5.0f) {\n            timer_ = 0.0f;\n            // Spawn new entity...\n        }\n    }\n};\n"})}),"\n",(0,o.jsx)(n.h2,{id:"update-order",children:"Update Order"}),"\n",(0,o.jsx)(n.p,{children:"Each frame, the GameWorld executes updates in this order:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"GameObject Updates:"})," All components implementing ",(0,o.jsx)(n.code,{children:"Updatable"})," are updated"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"System Updates:"})," All registered Systems are updated in registration order"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Post-Frame Cleanup:"})," Clear systems reset dirty flags"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This ordering ensures that component state is computed before systems process global logic."}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Keep Components Focused:"}),' Each component should represent a single aspect of an entity (health, physics, rendering link). Avoid "god components" that do everything.']}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use Systems for Cross-Cutting Concerns:"})," Physics simulation, collision detection, and pooling are ideal for Systems because they need access to multiple entities."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Prefer Composition:"})," Instead of creating specialized GameObject subclasses, configure entities by attaching different component combinations."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Instead of: class Player : public GameObject { ... }\n\n// Do this:\nauto player = std::make_unique<GameObject>();\nplayer->add<SceneNodeComponent>(node);\nplayer->add<Move2DComponent>();\nplayer->add<HealthComponent>();\nplayer->add<PlayerInputComponent>();\n"})})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}}}]);