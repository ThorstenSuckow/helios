"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[14438],{28453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>r});var t=s(96540);const o={},i=t.createContext(o);function c(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),t.createElement(i.Provider,{value:n},e.children)}},33797:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"core-concepts/component-system","title":"Component System","description":"Composition-based entity design with Components, Systems, and GameWorld for flexible game logic.","source":"@site/docs/core-concepts/component-system.md","sourceDirName":"core-concepts","slug":"/core-concepts/component-system","permalink":"/docs/core-concepts/component-system","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/component-system.md","tags":[{"inline":true,"label":"gameplay","permalink":"/docs/tags/gameplay"},{"inline":true,"label":"architecture","permalink":"/docs/tags/architecture"}],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Component System","description":"Composition-based entity design with Components, Systems, and GameWorld for flexible game logic.","slug":"/core-concepts/component-system","sidebar_label":"Component System","sidebar_position":3,"tags":["gameplay","architecture"],"keywords":["helios","component","system","GameObject","GameWorld","composition"]},"sidebar":"tutorialSidebar","previous":{"title":"Conventions","permalink":"/docs/core-concepts/conventions"},"next":{"title":"Game Loop","permalink":"/docs/core-concepts/gameloop-architecture"}}');var o=s(74848),i=s(28453);const c={title:"Component System",description:"Composition-based entity design with Components, Systems, and GameWorld for flexible game logic.",slug:"/core-concepts/component-system",sidebar_label:"Component System",sidebar_position:3,tags:["gameplay","architecture"],keywords:["helios","component","system","GameObject","GameWorld","composition"]},r="Component System",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Key Classes",id:"key-classes",level:2},{value:"<code>Component</code>",id:"component",level:3},{value:"Component Enabled State",id:"component-enabled-state",level:4},{value:"<code>GameObject</code>",id:"gameobject",level:3},{value:"<code>System</code>",id:"system",level:3},{value:"<code>GameWorld</code>",id:"gameworld",level:3},{value:"<code>GameLoop</code>",id:"gameloop",level:3},{value:"Built-in Components",id:"built-in-components",level:2},{value:"Spatial/Transform",id:"spatialtransform",level:3},{value:"Physics/Motion",id:"physicsmotion",level:3},{value:"Physics/Collision",id:"physicscollision",level:3},{value:"Gameplay",id:"gameplay",level:3},{value:"Scene",id:"scene",level:3},{value:"Input",id:"input",level:3},{value:"Built-in Systems",id:"built-in-systems",level:2},{value:"Pre Phase Systems",id:"pre-phase-systems",level:3},{value:"Main Phase Systems",id:"main-phase-systems",level:3},{value:"Post Phase Systems",id:"post-phase-systems",level:3},{value:"Creating Custom Components",id:"creating-custom-components",level:2},{value:"Creating Custom Systems",id:"creating-custom-systems",level:2},{value:"Querying GameObjects",id:"querying-gameobjects",level:2},{value:"GameObjectFilter",id:"gameobjectfilter",level:3},{value:"Filtering Examples",id:"filtering-examples",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"component-system",children:"Component System"})}),"\n",(0,o.jsxs)(n.p,{children:["helios implements a ",(0,o.jsx)(n.strong,{children:"composition-based component architecture"})," that separates data from behavior, enabling flexible and reusable game logic without deep inheritance hierarchies."]}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(n.p,{children:'The component system follows the "composition over inheritance" principle:'}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Components"})," store data for GameObjects (pure data containers)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Systems"})," operate on groups of GameObjects with specific component configurations"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"GameWorld"})," manages the lifecycle of GameObjects, Managers, and Pools"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"GameLoop"})," orchestrates Systems across Phases and Passes"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This design allows you to build complex entities by mixing and matching components rather than creating specialized subclasses."}),"\n",(0,o.jsx)(n.h2,{id:"key-classes",children:"Key Classes"}),"\n",(0,o.jsx)(n.h3,{id:"component",children:(0,o.jsx)(n.code,{children:"Component"})}),"\n",(0,o.jsxs)(n.p,{children:["The base class for all components attached to a GameObject. Components are ",(0,o.jsx)(n.strong,{children:"data containers"})," \u2014 they store state but should not contain complex update logic."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.ecs.Component;\n\nclass HealthComponent : public helios::engine::ecs::Component {\n    int health_ = 100;\npublic:\n    void takeDamage(int amount) { health_ -= amount; }\n    int health() const { return health_; }\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Components receive a back-reference to their owning GameObject via ",(0,o.jsx)(n.code,{children:"onAttach()"}),", allowing them to interact with sibling components or the entity as a whole."]}),"\n",(0,o.jsx)(n.h4,{id:"component-enabled-state",children:"Component Enabled State"}),"\n",(0,o.jsxs)(n.p,{children:["Each component has an ",(0,o.jsx)(n.code,{children:"isEnabled()"})," flag that controls whether it participates in system processing:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"bool isEnabled() const noexcept;\nbool isDisabled() const noexcept;\nvoid enable() noexcept;\nvoid disable() noexcept;\n"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"State"}),(0,o.jsx)(n.th,{children:"Meaning"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"isEnabled() == true"})}),(0,o.jsx)(n.td,{children:"Component is active and processed by systems"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"isEnabled() == false"})}),(0,o.jsx)(n.td,{children:"Component is skipped by systems but remains attached"})]})]})]}),"\n",(0,o.jsxs)(n.p,{children:["This allows fine-grained control over individual components without removing them from the GameObject. For example, temporarily disabling a ",(0,o.jsx)(n.code,{children:"CollisionComponent"})," makes an entity pass through walls."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Important:"})," Disabling a component does ",(0,o.jsx)(n.strong,{children:"not"})," disable the entire GameObject. Use ",(0,o.jsx)(n.code,{children:"GameObject::setActive(false)"})," to exclude an entity from all processing. See ",(0,o.jsx)(n.a,{href:"/docs/core-concepts/conventions#gameobject-active-state",children:"Conventions: GameObject Active State"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"gameobject",children:(0,o.jsx)(n.code,{children:"GameObject"})}),"\n",(0,o.jsx)(n.p,{children:"A container for components that represents an entity in the game world."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.ecs.GameObject;\n\nauto entity = std::make_unique<helios::engine::ecs::GameObject>();\n\n// Add components to define behavior\nentity->add<SceneNodeComponent>(sceneNode);\nentity->add<Move2DComponent>();\nentity->add<HealthComponent>();\n\n// Retrieve components by type (O(1) lookup)\nauto* health = entity->get<HealthComponent>();\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Each GameObject has a unique ",(0,o.jsx)(n.code,{children:"Guid"})," for identification and can be queried efficiently via ",(0,o.jsx)(n.code,{children:"GameWorld::find<Components...>()"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"system",children:(0,o.jsx)(n.code,{children:"System"})}),"\n",(0,o.jsxs)(n.p,{children:["Global logic processors that operate on the entire GameWorld. Systems are registered with the ",(0,o.jsx)(n.strong,{children:"GameLoop"})," and executed within Phases and Passes."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.ecs.System;\n\nclass PhysicsSystem : public helios::engine::ecs::System {\npublic:\n    void update(UpdateContext& ctx) noexcept override {\n        // Iterate all active GameObjects with Move2DComponent\n        for (auto [obj, move] : ctx.gameWorld().find<Move2DComponent>().each()) {\n            auto* node = obj->get<SceneNodeComponent>();\n            // Apply physics simulation...\n        }\n    }\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Systems are organized into Phases (Pre, Main, Post) and Passes within each Phase. See ",(0,o.jsx)(n.a,{href:"/docs/core-concepts/gameloop-architecture",children:"Game Loop Architecture"})," for details."]}),"\n",(0,o.jsx)(n.h3,{id:"gameworld",children:(0,o.jsx)(n.code,{children:"GameWorld"})}),"\n",(0,o.jsx)(n.p,{children:"The root container managing GameObjects, Managers, and Pools."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.runtime.world.GameWorld;\n\nhelios::engine::runtime::world::GameWorld world;\n\n// Add entities\nauto* player = world.addGameObject(std::move(playerEntity));\n\n// Add managers for deferred processing\nworld.addManager<ProjectilePoolManager>(poolId);\n\n// Query entities by component\nfor (auto* obj : world.find<Move2DComponent, SceneNodeComponent>()) {\n    // Process matching entities\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"gameloop",children:(0,o.jsx)(n.code,{children:"GameLoop"})}),"\n",(0,o.jsx)(n.p,{children:"The orchestrator for system execution. Systems are added to Phases and Passes:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.runtime.gameloop.GameLoop;\n\nGameLoop gameLoop;\n\n// Pre Phase: Input processing\ngameLoop.phase(PhaseType::Pre)\n    .addPass()\n    .addSystem<InputSystem>(gameWorld);\n\n// Main Phase: Gameplay logic\ngameLoop.phase(PhaseType::Main)\n    .addPass()\n    .addSystem<Move2DSystem>(gameWorld)\n    .addSystem<CollisionSystem>(gameWorld);\n\n// Post Phase: Synchronization\ngameLoop.phase(PhaseType::Post)\n    .addPass()\n    .addSystem<SceneSyncSystem>(gameWorld, scene);\n\n// Initialize and run\ngameLoop.init(gameWorld);\ngameLoop.update(gameWorld, deltaTime, inputSnapshot);\n"})}),"\n",(0,o.jsx)(n.h2,{id:"built-in-components",children:"Built-in Components"}),"\n",(0,o.jsx)(n.p,{children:"helios provides several ready-to-use components organized by domain:"}),"\n",(0,o.jsx)(n.h3,{id:"spatialtransform",children:"Spatial/Transform"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Component"}),(0,o.jsx)(n.th,{children:"Purpose"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"TransformComponent"})}),(0,o.jsx)(n.td,{children:"Stores local transform with dirty tracking"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"ScaleComponent"})}),(0,o.jsx)(n.td,{children:"Unit-based sizing using helios units (meters)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"TranslationStateComponent"})}),(0,o.jsx)(n.td,{children:"Translation delta for frame-based movement"})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"physicsmotion",children:"Physics/Motion"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Component"}),(0,o.jsx)(n.th,{children:"Purpose"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Move2DComponent"})}),(0,o.jsx)(n.td,{children:"2D movement parameters (max speed, acceleration, dampening)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"HeadingComponent"})}),(0,o.jsx)(n.td,{children:"Rotation state and target angle"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"DirectionComponent"})}),(0,o.jsx)(n.td,{children:"Normalized movement direction"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"SpinComponent"})}),(0,o.jsx)(n.td,{children:"Continuous rotation (spin speed)"})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"physicscollision",children:"Physics/Collision"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Component"}),(0,o.jsx)(n.th,{children:"Purpose"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"AabbColliderComponent"})}),(0,o.jsx)(n.td,{children:"Axis-aligned bounding box for collision"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CollisionComponent"})}),(0,o.jsx)(n.td,{children:"Collision configuration (layer, mask, response type)"})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"gameplay",children:"Gameplay"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Component"}),(0,o.jsx)(n.th,{children:"Purpose"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"LevelBoundsBehaviorComponent"})}),(0,o.jsx)(n.td,{children:"Arena boundary interaction (bounce, clamp, wrap, despawn)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"ShootComponent"})}),(0,o.jsx)(n.td,{children:"Projectile firing with cooldown timer"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Aim2DComponent"})}),(0,o.jsx)(n.td,{children:"Aiming direction for twin-stick controls"})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"scene",children:"Scene"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Component"}),(0,o.jsx)(n.th,{children:"Purpose"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"SceneNodeComponent"})}),(0,o.jsx)(n.td,{children:"Links a GameObject to a scene graph node"})]})})]}),"\n",(0,o.jsx)(n.h3,{id:"input",children:"Input"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Component"}),(0,o.jsx)(n.th,{children:"Purpose"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"TwinStickInputComponent"})}),(0,o.jsx)(n.td,{children:"Dual analog stick input mapping"})]})})]}),"\n",(0,o.jsx)(n.h2,{id:"built-in-systems",children:"Built-in Systems"}),"\n",(0,o.jsx)(n.p,{children:"Systems are organized by their typical Phase placement:"}),"\n",(0,o.jsx)(n.h3,{id:"pre-phase-systems",children:"Pre Phase Systems"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"System"}),(0,o.jsx)(n.th,{children:"Purpose"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Input processing systems"}),(0,o.jsx)(n.td,{children:"Read input, generate Commands"})]})})]}),"\n",(0,o.jsx)(n.h3,{id:"main-phase-systems",children:"Main Phase Systems"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"System"}),(0,o.jsx)(n.th,{children:"Purpose"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Move2DSystem"})}),(0,o.jsx)(n.td,{children:"Applies velocity/acceleration to TransformComponent"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"HeadingSystem"})}),(0,o.jsx)(n.td,{children:"Smoothly rotates entities toward target angle"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"SpinSystem"})}),(0,o.jsx)(n.td,{children:"Applies continuous rotation"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"BoundsUpdateSystem"})}),(0,o.jsx)(n.td,{children:"Updates AABB colliders from transforms"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"GridCollisionDetectionSystem"})}),(0,o.jsx)(n.td,{children:"Spatial partitioning collision detection"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"LevelBoundsBehaviorSystem"})}),(0,o.jsx)(n.td,{children:"Handles boundary collision behaviors"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"ComposeTransformSystem"})}),(0,o.jsx)(n.td,{children:"Composes transform from translation/rotation/scale"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"ScaleSystem"})}),(0,o.jsx)(n.td,{children:"Applies scale changes"})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"post-phase-systems",children:"Post Phase Systems"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"System"}),(0,o.jsx)(n.th,{children:"Purpose"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"SceneSyncSystem"})}),(0,o.jsx)(n.td,{children:"Syncs transforms from gameplay to scene graph"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"TransformClearSystem"})}),(0,o.jsx)(n.td,{children:"Clears dirty flags after frame"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"ScaleClearSystem"})}),(0,o.jsx)(n.td,{children:"Clears scale dirty flags"})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"creating-custom-components",children:"Creating Custom Components"}),"\n",(0,o.jsxs)(n.p,{children:["Define a class inheriting from ",(0,o.jsx)(n.code,{children:"Component"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"export module myproject.components.Inventory;\n\nimport helios.engine.ecs.Component;\n\nexport class InventoryComponent : public helios::engine::ecs::Component {\n    std::vector<Item> items_;\n    \npublic:\n    void addItem(Item item) { items_.push_back(std::move(item)); }\n    const std::vector<Item>& items() const { return items_; }\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["For components that need cloning (e.g., for object pools), implement ",(0,o.jsx)(n.code,{children:"CloneableComponent"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.ecs.CloneableComponent;\n\nclass HealthComponent : public helios::engine::ecs::CloneableComponent {\n    int maxHealth_ = 100;\n    int currentHealth_ = 100;\n    \npublic:\n    std::unique_ptr<Component> clone() const override {\n        auto copy = std::make_unique<HealthComponent>();\n        copy->maxHealth_ = maxHealth_;\n        copy->currentHealth_ = maxHealth_;  // Reset to max on clone\n        return copy;\n    }\n};\n"})}),"\n",(0,o.jsx)(n.h2,{id:"creating-custom-systems",children:"Creating Custom Systems"}),"\n",(0,o.jsxs)(n.p,{children:["Define a class inheriting from ",(0,o.jsx)(n.code,{children:"System"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"export module myproject.systems.Spawner;\n\nimport helios.engine.ecs.System;\n\nexport class SpawnerSystem : public helios::engine::ecs::System {\n    float timer_ = 0.0f;\n    \npublic:\n    explicit SpawnerSystem(GameWorld& world) : System(world) {}\n    \n    void update(UpdateContext& ctx) noexcept override {\n        timer_ += ctx.deltaTime();\n        if (timer_ > 5.0f) {\n            timer_ = 0.0f;\n            // Queue spawn via CommandBuffer\n            ctx.commandBuffer().add<SpawnCommand>(position, enemyType);\n        }\n    }\n};\n"})}),"\n",(0,o.jsx)(n.h2,{id:"querying-gameobjects",children:"Querying GameObjects"}),"\n",(0,o.jsx)(n.p,{children:"GameWorld provides efficient component-based queries:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Find all GameObjects with specific components\nfor (auto* obj : gameWorld.find<Move2DComponent, SceneNodeComponent>()) {\n    // obj has both components\n}\n\n// Using structured bindings for direct component access\nfor (auto [obj, move, node] : gameWorld.find<Move2DComponent, SceneNodeComponent>().each()) {\n    // move and node are references to the components\n}\n\n// Filter by active state\nfor (auto* obj : gameWorld.find<HealthComponent>(GameObjectFilter::Active)) {\n    // Only active GameObjects\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"gameobjectfilter",children:"GameObjectFilter"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"GameObjectFilter"})," enum controls which GameObjects are included in query results:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"import helios.engine.ecs.query.GameObjectFilter;\n\nusing helios::engine::ecs::query::GameObjectFilter;\n"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Filter"}),(0,o.jsx)(n.th,{children:"Meaning"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"GameObjectFilter::None"})}),(0,o.jsx)(n.td,{children:"No filtering (default)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"GameObjectFilter::Active"})}),(0,o.jsxs)(n.td,{children:["Only ",(0,o.jsx)(n.code,{children:"obj->isActive() == true"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"GameObjectFilter::Inactive"})}),(0,o.jsxs)(n.td,{children:["Only ",(0,o.jsx)(n.code,{children:"obj->isActive() == false"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"GameObjectFilter::ComponentEnabled"})}),(0,o.jsx)(n.td,{children:"Only objects with enabled queried components"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"GameObjectFilter::ComponentDisabled"})}),(0,o.jsx)(n.td,{children:"Only objects with disabled queried components"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"GameObjectFilter::All"})}),(0,o.jsx)(n.td,{children:"All GameObjects regardless of state"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:"Filters can be combined using bitwise OR:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Find inactive objects with disabled components\nauto filter = GameObjectFilter::Inactive | GameObjectFilter::ComponentDisabled;\nfor (auto* obj : gameWorld.find<CollisionComponent>(filter)) {\n    // Process matching objects\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"filtering-examples",children:"Filtering Examples"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Active GameObjects with enabled components:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"void update(UpdateContext& ctx) noexcept override {\n    auto filter = GameObjectFilter::Active | GameObjectFilter::ComponentEnabled;\n    \n    for (auto [obj, move, collision] : gameWorld_->find<Move2DComponent, CollisionComponent>(filter).each()) {\n        // Both GameObject is active AND components are enabled\n        // No manual checks required\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Manual filtering (alternative approach):"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"void update(UpdateContext& ctx) noexcept override {\n    for (auto [obj, move, collision] : gameWorld_->find<Move2DComponent, CollisionComponent>().each()) {\n        \n        // Skip inactive GameObjects\n        if (!obj->isActive()) {\n            continue;\n        }\n        \n        // Skip disabled components\n        if (collision.isDisabled()) {\n            continue;  // Movement still applies, but no collision\n        }\n        \n        // Process with collision enabled...\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Finding disabled components (e.g., for re-enabling):"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Find objects where invulnerability expired\nfor (auto [obj, invuln] : gameWorld_->find<InvulnerabilityComponent>(\n        GameObjectFilter::Active | GameObjectFilter::ComponentDisabled).each()) {\n    // Re-enable collision after invulnerability ends\n    obj->get<CollisionComponent>()->enable();\n}\n\n## Update Order\n\nThe GameLoop executes updates in three phases:\n\n"})}),"\n",(0,o.jsx)(n.p,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                          FRAME                                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                 \u2502\n\u2502  PRE PHASE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500   \u2502\n\u2502    Pass 1: Input systems                                        \u2502\n\u2502    [Phase Commit: Commands flush, Managers process]             \u2502\n\u2502                                                                 \u2502\n\u2502  MAIN PHASE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500   \u2502\n\u2502    Pass 1: Movement, Physics                                    \u2502\n\u2502    Pass 2: Collision Detection                                  \u2502\n\u2502    Pass 3: Gameplay Systems                                     \u2502\n\u2502    [Phase Commit: Commands flush, Managers process]             \u2502\n\u2502                                                                 \u2502\n\u2502  POST PHASE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500   \u2502\n\u2502    Pass 1: Scene Sync                                           \u2502\n\u2502    Pass 2: Cleanup (clear dirty flags)                          \u2502\n\u2502    [Phase Commit: Commands flush, Managers process]             \u2502\n\u2502                                                                 \u2502\n\u2502                        RENDER                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"\nSee [Game Loop Architecture](/docs/core-concepts/gameloop-architecture) for detailed phase/pass event handling.\n\n## Best Practices\n\n**Keep Components as Data Containers:** Components should store state, not complex logic. Move update logic to Systems.\n\n**Use Systems for Cross-Cutting Concerns:** Physics simulation, collision detection, and scene synchronization belong in Systems.\n\n**Prefer Composition:** Configure entities by attaching different component combinations rather than creating specialized subclasses.\n\n```cpp\n// Instead of: class Player : public GameObject { ... }\n\n// Do this:\nauto player = std::make_unique<GameObject>();\nplayer->add<SceneNodeComponent>(node);\nplayer->add<Move2DComponent>();\nplayer->add<HeadingComponent>();\nplayer->add<HealthComponent>();\nplayer->add<TwinStickInputComponent>();\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use Commands for State Mutations:"})," Instead of mutating state directly in Systems, emit Commands to the CommandBuffer for deterministic execution."]}),"\n",(0,o.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/gameloop-architecture",children:"Game Loop Architecture"})," \u2014 Phase/Pass structure, commit points"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/command-system",children:"Command System"})," \u2014 Deferred action execution"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/core-concepts/event-system",children:"Event System"})," \u2014 Phase/pass event propagation"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}}}]);