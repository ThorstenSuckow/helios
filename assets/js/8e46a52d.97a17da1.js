"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[10772],{28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var t=s(96540);const i={},r=t.createContext(i);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},72541:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"core-concepts/conventions","title":"Technical Conventions","description":"Coordinate systems (LHS), matrix storage (column-major), units (1 hu = 1 m), and mathematical foundations used in helios.","source":"@site/docs/core-concepts/conventions.md","sourceDirName":"core-concepts","slug":"/core-concepts/conventions","permalink":"/docs/core-concepts/conventions","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/conventions.md","tags":[{"inline":true,"label":"math","permalink":"/docs/tags/math"},{"inline":true,"label":"architecture","permalink":"/docs/tags/architecture"}],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Technical Conventions","description":"Coordinate systems (LHS), matrix storage (column-major), units (1 hu = 1 m), and mathematical foundations used in helios.","slug":"/core-concepts/conventions","sidebar_label":"Conventions","sidebar_position":2,"tags":["math","architecture"],"keywords":["helios","coordinate system","left-handed","matrix","column-major","conventions","units"]},"sidebar":"tutorialSidebar","previous":{"title":"Scene Graph","permalink":"/docs/core-concepts/scene-graph"},"next":{"title":"Component System","permalink":"/docs/core-concepts/component-system"}}');var i=s(74848),r=s(28453);const o={title:"Technical Conventions",description:"Coordinate systems (LHS), matrix storage (column-major), units (1 hu = 1 m), and mathematical foundations used in helios.",slug:"/core-concepts/conventions",sidebar_label:"Conventions",sidebar_position:2,tags:["math","architecture"],keywords:["helios","coordinate system","left-handed","matrix","column-major","conventions","units"]},a="helios Technical Conventions",c={},l=[{value:"Coordinate System",id:"coordinate-system",level:2},{value:"Left-Handed System (LHS)",id:"left-handed-system-lhs",level:3},{value:"OpenGL Compatibility",id:"opengl-compatibility",level:3},{value:"Matrix Conventions",id:"matrix-conventions",level:2},{value:"Storage Format: Column-Major Order",id:"storage-format-column-major-order",level:3},{value:"Element Access",id:"element-access",level:3},{value:"Translation Components",id:"translation-components",level:3},{value:"Rotation and Scale Components",id:"rotation-and-scale-components",level:3},{value:"Matrix Multiplication Order",id:"matrix-multiplication-order",level:3},{value:"View Matrix Construction",id:"view-matrix-construction",level:2},{value:"Projection Matrix",id:"projection-matrix",level:2},{value:"Units System",id:"units-system",level:2},{value:"Standard Units",id:"standard-units",level:3},{value:"Helios Units (hu)",id:"helios-units-hu",level:3},{value:"Usage Example",id:"usage-example",level:3},{value:"Constants",id:"constants",level:3},{value:"Related Modules",id:"related-modules",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"helios-technical-conventions",children:"helios Technical Conventions"})}),"\n",(0,i.jsx)(n.p,{children:"This document describes the fundamental technical conventions used throughout the helios engine, including coordinate systems, matrix storage, and related mathematical foundations."}),"\n",(0,i.jsx)(n.h2,{id:"coordinate-system",children:"Coordinate System"}),"\n",(0,i.jsx)(n.h3,{id:"left-handed-system-lhs",children:"Left-Handed System (LHS)"}),"\n",(0,i.jsxs)(n.p,{children:["helios uses a ",(0,i.jsx)(n.strong,{children:"Left-Handed Coordinate System"})," (LHS) as its primary spatial convention:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"+X axis"}),": Points to the right"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"+Y axis"}),": Points upward"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"+Z axis"}),": Points forward (into the screen)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:'This convention aligns with common game engine practices and provides intuitive "depth" semantics where positive Z values represent objects further away from the viewer.'}),"\n",(0,i.jsx)(n.h3,{id:"opengl-compatibility",children:"OpenGL Compatibility"}),"\n",(0,i.jsxs)(n.p,{children:["While helios internally uses LHS, OpenGL expects a Right-Handed System (RHS) where the camera looks down the ",(0,i.jsx)(n.strong,{children:"-Z axis"}),". The engine handles this conversion transparently:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"CameraSceneNode::worldTransform()"})," computes the View Matrix by inverting the camera's world transform"]}),"\n",(0,i.jsx)(n.li,{children:"The Z-axis is negated during View Matrix construction to convert from LHS to OpenGL's RHS clip space"}),"\n",(0,i.jsx)(n.li,{children:"Near and far plane values remain positive regardless of the camera's orientation"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Example:"})," An object at world position ",(0,i.jsx)(n.code,{children:"(0, 0, 5)"})," in helios (5 units in front of the origin) will be correctly rendered when the camera is positioned to view it, with the projection handling the LHS-to-RHS conversion."]}),"\n",(0,i.jsx)(n.h2,{id:"matrix-conventions",children:"Matrix Conventions"}),"\n",(0,i.jsx)(n.h3,{id:"storage-format-column-major-order",children:"Storage Format: Column-Major Order"}),"\n",(0,i.jsxs)(n.p,{children:["All ",(0,i.jsx)(n.code,{children:"mat4"})," matrices in helios are stored in ",(0,i.jsx)(n.strong,{children:"column-major order"}),". This means:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The internal array ",(0,i.jsx)(n.code,{children:"m[16]"})," stores elements column by column"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"m[0..3]"})," = Column 0 (elements at rows 0-3)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"m[4..7]"})," = Column 1 (elements at rows 0-3)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"m[8..11]"})," = Column 2 (elements at rows 0-3)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"m[12..15]"})," = Column 3 (elements at rows 0-3)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"element-access",children:"Element Access"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"operator()(row, col)"})," provides intuitive mathematical notation:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Access element at row r, column c\nT value = matrix(r, c);  // Internally: m[r + c * 4]\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Memory layout visualization:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Mathematical notation:     Memory layout (column-major):\n| m(0,0) m(0,1) m(0,2) m(0,3) |     m[0]  m[4]  m[8]  m[12]\n| m(1,0) m(1,1) m(1,2) m(1,3) |     m[1]  m[5]  m[9]  m[13]\n| m(2,0) m(2,1) m(2,2) m(2,3) |     m[2]  m[6]  m[10] m[14]\n| m(3,0) m(3,1) m(3,2) m(3,3) |     m[3]  m[7]  m[11] m[15]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"translation-components",children:"Translation Components"}),"\n",(0,i.jsxs)(n.p,{children:["In a standard 4x4 transformation matrix, the ",(0,i.jsx)(n.strong,{children:"translation vector"})," is stored in ",(0,i.jsx)(n.strong,{children:"column 3"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Extracting translation from a transform matrix\nhelios::math::vec3f translation(\n    matrix(0, 3),  // X translation (m[12])\n    matrix(1, 3),  // Y translation (m[13])\n    matrix(2, 3)   // Z translation (m[14])\n);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"rotation-and-scale-components",children:"Rotation and Scale Components"}),"\n",(0,i.jsx)(n.p,{children:"The upper-left 3x3 submatrix contains rotation and scale:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Extracting basis vectors (columns)\nvec3f xAxis(matrix(0, 0), matrix(1, 0), matrix(2, 0));  // Column 0\nvec3f yAxis(matrix(0, 1), matrix(1, 1), matrix(2, 1));  // Column 1\nvec3f zAxis(matrix(0, 2), matrix(1, 2), matrix(2, 2));  // Column 2\n"})}),"\n",(0,i.jsx)(n.h3,{id:"matrix-multiplication-order",children:"Matrix Multiplication Order"}),"\n",(0,i.jsxs)(n.p,{children:["helios uses ",(0,i.jsx)(n.strong,{children:"post-multiplication"})," (column-vector convention):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Transform a point: result = M * v\nvec4f transformed = matrix * vec4f(point, 1.0f);\n\n// Combining transforms: first A, then B\nmat4f combined = B * A;  // A is applied first, then B\n"})}),"\n",(0,i.jsx)(n.h2,{id:"view-matrix-construction",children:"View Matrix Construction"}),"\n",(0,i.jsx)(n.p,{children:"The View Matrix is computed as the inverse of the camera's World Transform. For a camera node:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// In CameraSceneNode::worldTransform()\nconst auto wt = SceneNode::worldTransform();\n\n// Extract basis vectors and eye position\nconst auto x = vec3f{wt(0, 0), wt(1, 0), wt(2, 0)};\nconst auto y = vec3f{wt(0, 1), wt(1, 1), wt(2, 1)};\nconst auto z = vec3f{wt(0, 2), wt(1, 2), wt(2, 2)};\nconst auto eye = vec3f{wt(0, 3), wt(1, 3), wt(2, 3)};\n\n// Construct inverse (View Matrix) with Z-negation for OpenGL\nmat4f viewMatrix = mat4f{\n    x[0],  y[0], -z[0], 0.0f,\n    x[1],  y[1], -z[1], 0.0f,\n    x[2],  y[2], -z[2], 0.0f,\n    -dot(x, eye), -dot(y, eye), dot(z, eye), 1.0f\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"The negation of the Z-axis converts from helios LHS to OpenGL's RHS expectation."}),"\n",(0,i.jsx)(n.h2,{id:"projection-matrix",children:"Projection Matrix"}),"\n",(0,i.jsx)(n.p,{children:"Perspective projection uses standard parameters:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"fovY"})}),(0,i.jsxs)(n.td,{children:["Vertical field of view in ",(0,i.jsx)(n.strong,{children:"radians"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"aspectRatio"})}),(0,i.jsx)(n.td,{children:"Width / Height ratio"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"zNear"})}),(0,i.jsx)(n.td,{children:"Near clipping plane distance (positive)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"zFar"})}),(0,i.jsx)(n.td,{children:"Far clipping plane distance (positive)"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["Both ",(0,i.jsx)(n.code,{children:"zNear"})," and ",(0,i.jsx)(n.code,{children:"zFar"})," are specified as positive values representing distances from the camera, regardless of the coordinate system handedness."]}),"\n",(0,i.jsx)(n.h2,{id:"units-system",children:"Units System"}),"\n",(0,i.jsx)(n.h3,{id:"standard-units",children:"Standard Units"}),"\n",(0,i.jsx)(n.p,{children:"helios uses a standardized unit system for consistent measurements across the engine:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Measurement"}),(0,i.jsx)(n.th,{children:"Standard Unit"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Distance"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Meter"})}),(0,i.jsx)(n.td,{children:"1 helios unit (hu) = 1 meter"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Time"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Seconds"})}),(0,i.jsx)(n.td,{children:"Used for delta time, animations"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"helios-units-hu",children:"Helios Units (hu)"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"helios unit"})," (hu) is the engine's standard unit of measurement:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"1 hu = 1 Meter"})}),"\n",(0,i.jsx)(n.li,{children:"All distances, positions, and sizes are expressed in meters by default"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This provides intuitive world-scale dimensions that match real-world measurements."}),"\n",(0,i.jsx)(n.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"import helios.core.units;\n\nusing namespace helios::core::units;\n\n// Available unit types\nenum class Unit { Meter, Centimeter, HeliosUnit };\n\n// Set object size in world units (meters)\ngameObject->setSize(2.0f, 1.0f, 0.5f, Unit::Meter);\n\n// A 5-meter tall object\nconstexpr float HEIGHT = 5.0f; // 5 hu = 5 meters\n"})}),"\n",(0,i.jsx)(n.h3,{id:"constants",children:"Constants"}),"\n",(0,i.jsxs)(n.p,{children:["Unit definitions are available as ",(0,i.jsx)(n.code,{children:"constexpr"})," in ",(0,i.jsx)(n.code,{children:"helios::core::units"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// 1 helios unit = 1 meter\nconstexpr float HELIOS_UNITS_PER_METER = 1.0f;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"related-modules",children:"Related Modules"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"helios.core.units"})," \u2014 Unit conversion and constants"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"helios.math.types"})," \u2014 Core vector and matrix types (",(0,i.jsx)(n.code,{children:"vec3f"}),", ",(0,i.jsx)(n.code,{children:"mat4f"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"helios.math.utils"})," \u2014 Mathematical utility functions (",(0,i.jsx)(n.code,{children:"perspective"}),", ",(0,i.jsx)(n.code,{children:"radians"}),", ",(0,i.jsx)(n.code,{children:"degrees"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"helios.scene.Transform"})," \u2014 Encapsulates translation, rotation, and scale"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"helios.scene.Camera"})," \u2014 Projection matrix management"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"helios.scene.CameraSceneNode"})," \u2014 View matrix computation and scene graph integration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"helios.scene.InheritTransform"})," \u2014 Selective transform inheritance flags"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);