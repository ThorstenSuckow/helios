"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[10385],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var s=n(96540);const i={},a=s.createContext(i);function r(e){const t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:t},e.children)}},50964:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"core-concepts/ecs/system","title":"System","description":"Abstract base class for game logic processors operating on the GameWorld.","source":"@site/docs/core-concepts/ecs/system.md","sourceDirName":"core-concepts/ecs","slug":"/core-concepts/ecs/system","permalink":"/docs/core-concepts/ecs/system","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/ecs/system.md","tags":[{"inline":true,"label":"ecs","permalink":"/docs/tags/ecs"},{"inline":true,"label":"architecture","permalink":"/docs/tags/architecture"},{"inline":true,"label":"system","permalink":"/docs/tags/system"}],"version":"current","sidebarPosition":6,"frontMatter":{"title":"System","description":"Abstract base class for game logic processors operating on the GameWorld.","slug":"/core-concepts/ecs/system","sidebar_label":"System","sidebar_position":6,"tags":["ecs","architecture","system"],"keywords":["helios","System","ECS","game logic","Updatable"]},"sidebar":"tutorialSidebar","previous":{"title":"View","permalink":"/docs/core-concepts/ecs/view"},"next":{"title":"Updatable","permalink":"/docs/core-concepts/ecs/updatable"}}');var i=n(74848),a=n(28453);const r={title:"System",description:"Abstract base class for game logic processors operating on the GameWorld.",slug:"/core-concepts/ecs/system",sidebar_label:"System",sidebar_position:6,tags:["ecs","architecture","system"],keywords:["helios","System","ECS","game logic","Updatable"]},c="System",o={},l=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"API Reference",id:"api-reference",level:2},{value:"Base Class",id:"base-class",level:3},{value:"init()",id:"init",level:3},{value:"update()",id:"update",level:3},{value:"UpdateContext",id:"updatecontext",level:2},{value:"Creating Systems",id:"creating-systems",level:2},{value:"Basic System",id:"basic-system",level:3},{value:"System with State",id:"system-with-state",level:3},{value:"System with Initialization",id:"system-with-initialization",level:3},{value:"Updatable Interface",id:"updatable-interface",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Keep Systems Focused",id:"1-keep-systems-focused",level:3},{value:"2. Use Views for Queries",id:"2-use-views-for-queries",level:3},{value:"3. Defer Structural Changes",id:"3-defer-structural-changes",level:3},{value:"4. noexcept Guarantee",id:"4-noexcept-guarantee",level:3},{value:"See Also",id:"see-also",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"system",children:"System"})}),"\n",(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.strong,{children:"System"})," is an abstract base class for game logic processors that operate on the GameWorld. Systems implement cross-cutting concerns like physics, collision detection, or AI."]}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(t.p,{children:"Systems follow the ECS pattern of separating behavior from data:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Components"})," hold data"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Systems"})," implement behavior"]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"class PhysicsSystem : public System {\npublic:\n    void update(UpdateContext& ctx) noexcept override {\n        for (auto [entity, transform, velocity] : gameWorld_->view<\n            TransformComponent,\n            VelocityComponent,\n            Active\n        >().whereEnabled()) {\n            transform->position += velocity->direction * ctx.deltaTime;\n        }\n    }\n};\n\n// Register with GameWorld\ngameWorld.addSystem(std::make_unique<PhysicsSystem>());\n"})}),"\n",(0,i.jsx)(t.h2,{id:"architecture",children:"Architecture"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        GameWorld                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n\u2502  \u2502                    Systems                              \u2502\u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\u2502\n\u2502  \u2502  \u2502 Physics  \u2502 \u2502Collision \u2502 \u2502    AI    \u2502  ...            \u2502\u2502\n\u2502  \u2502  \u2502 System   \u2502 \u2502  System  \u2502 \u2502  System  \u2502                 \u2502\u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502\u2502\n\u2502  \u2502       \u2502            \u2502            \u2502                       \u2502\u2502\n\u2502  \u2502       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                       \u2502\u2502\n\u2502  \u2502                    \u25bc                                    \u2502\u2502\n\u2502  \u2502              GameWorld Data                             \u2502\u2502\n\u2502  \u2502         (Entities, Components)                          \u2502\u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsx)(t.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,i.jsx)(t.h3,{id:"base-class",children:"Base Class"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"class System : public Updatable {\nprotected:\n    GameWorld* gameWorld_ = nullptr;\n\npublic:\n    virtual ~System() = default;\n    \n    virtual void init(GameWorld& gameWorld) noexcept;\n    void update(UpdateContext& updateContext) noexcept override = 0;\n};\n"})}),"\n",(0,i.jsx)(t.h3,{id:"init",children:"init()"}),"\n",(0,i.jsx)(t.p,{children:"Called once when the system is added to the GameWorld:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"void init(GameWorld& gameWorld) noexcept override {\n    System::init(gameWorld);  // Sets gameWorld_\n    \n    // Custom initialization\n    physicsWorld_ = createPhysicsWorld();\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"update",children:"update()"}),"\n",(0,i.jsx)(t.p,{children:"Called every frame with timing and context information:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"void update(UpdateContext& ctx) noexcept override {\n    float dt = ctx.deltaTime;\n    \n    for (auto [entity, physics] : gameWorld_->view<PhysicsComponent>()) {\n        // Update physics simulation\n    }\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"updatecontext",children:"UpdateContext"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"UpdateContext"})," provides frame-specific information:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"struct UpdateContext {\n    float deltaTime;           // Time since last frame (seconds)\n    CommandBuffer* commands;   // For deferred operations\n    GameWorld* gameWorld;      // Reference to the world\n    // ... additional context\n};\n"})}),"\n",(0,i.jsx)(t.h2,{id:"creating-systems",children:"Creating Systems"}),"\n",(0,i.jsx)(t.h3,{id:"basic-system",children:"Basic System"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"class GravitySystem : public System {\npublic:\n    void update(UpdateContext& ctx) noexcept override {\n        for (auto [entity, velocity, gravity, active] : gameWorld_->view<\n            VelocityComponent,\n            GravityComponent,\n            Active\n        >().whereEnabled()) {\n            velocity->velocity.y -= gravity->strength * ctx.deltaTime;\n        }\n    }\n};\n"})}),"\n",(0,i.jsx)(t.h3,{id:"system-with-state",children:"System with State"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"class SpawnTimerSystem : public System {\n    float spawnTimer_ = 0.0f;\n    float spawnInterval_ = 2.0f;\n\npublic:\n    void update(UpdateContext& ctx) noexcept override {\n        spawnTimer_ += ctx.deltaTime;\n        \n        if (spawnTimer_ >= spawnInterval_) {\n            spawnTimer_ = 0.0f;\n            ctx.commands->submit<SpawnEnemyCommand>();\n        }\n    }\n};\n"})}),"\n",(0,i.jsx)(t.h3,{id:"system-with-initialization",children:"System with Initialization"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"class CollisionSystem : public System {\n    std::unique_ptr<SpatialGrid> grid_;\n\npublic:\n    void init(GameWorld& gameWorld) noexcept override {\n        System::init(gameWorld);\n        \n        // Create spatial partitioning grid\n        grid_ = std::make_unique<SpatialGrid>(worldBounds_, cellSize_);\n    }\n    \n    void update(UpdateContext& ctx) noexcept override {\n        grid_->clear();\n        \n        // Populate grid and detect collisions\n    }\n};\n"})}),"\n",(0,i.jsx)(t.h2,{id:"updatable-interface",children:"Updatable Interface"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"System"})," inherits from ",(0,i.jsx)(t.code,{children:"Updatable"}),", which defines the update contract:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"class Updatable {\npublic:\n    virtual ~Updatable() = default;\n    virtual void update(UpdateContext& updateContext) noexcept = 0;\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"This interface allows systems (and other updatable objects) to be processed uniformly by the game loop."}),"\n",(0,i.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(t.h3,{id:"1-keep-systems-focused",children:"1. Keep Systems Focused"}),"\n",(0,i.jsx)(t.p,{children:"Each system should have a single responsibility:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"// Good: Focused systems\nclass MovementSystem : public System { };\nclass CollisionSystem : public System { };\nclass DamageSystem : public System { };\n\n// Bad: God system\nclass EverythingSystem : public System { };  // Avoid\n"})}),"\n",(0,i.jsx)(t.h3,{id:"2-use-views-for-queries",children:"2. Use Views for Queries"}),"\n",(0,i.jsx)(t.p,{children:"Prefer views over manual iteration:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"// Good: View-based query\nfor (auto [e, t, v] : gameWorld_->view<Transform, Velocity>()) { }\n\n// Avoid: Manual iteration\nfor (auto& entity : gameWorld_->entities()) {\n    if (entity.has<Transform>() && entity.has<Velocity>()) { }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"3-defer-structural-changes",children:"3. Defer Structural Changes"}),"\n",(0,i.jsx)(t.p,{children:"Use commands for entity creation/destruction during update:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"void update(UpdateContext& ctx) noexcept override {\n    for (auto [entity, health, active] : gameWorld_->view<\n        HealthComponent, Active\n    >().whereEnabled()) {\n        if (health->isDead()) {\n            // Don't destroy directly during iteration!\n            ctx.commands->submit<DespawnCommand>(entity.entityHandle());\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"4-noexcept-guarantee",children:"4. noexcept Guarantee"}),"\n",(0,i.jsx)(t.p,{children:"System updates must not throw exceptions:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"void update(UpdateContext& ctx) noexcept override {\n    // All code paths must be exception-safe\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"see-also",children:"See Also"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"/docs/core-concepts/ecs/updatable",children:"Updatable"})," - Base interface for per-frame updates"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"/docs/core-concepts/ecs/view",children:"View"})," - Component-based entity queries"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"/docs/core-concepts/gameloop-architecture",children:"GameWorld"})," - System registration and execution"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"/docs/core-concepts/command-system",children:"Command System"})," - Deferred operations"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"/docs/core-concepts/component-system",children:"Component System"})," - ECS overview"]}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);