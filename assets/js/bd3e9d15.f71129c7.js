"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[47724],{28453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>t});var d=n(96540);const o={},i=d.createContext(o);function r(e){const s=d.useContext(i);return d.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),d.createElement(i.Provider,{value:s},e.children)}},72331:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>c});const d=JSON.parse('{"id":"helios/pages/todo","title":"todo","description":"Member helios::~Application  ()=default","source":"@site/docs/helios/pages/todo.md","sourceDirName":"helios/pages","slug":"/helios/pages/todo","permalink":"/docs/helios/pages/todo","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"current","frontMatter":{"slug":"/helios/pages/todo","custom_edit_url":null,"toc_max_heading_level":4,"keywords":["doxygen","reference","page"]},"sidebar":"doxygenSidebar","previous":{"title":"Macro Definitions","permalink":"/docs/helios/indices/files/defines"},"next":{"title":"Deprecated List","permalink":"/docs/helios/pages/deprecated"}}');var o=n(74848),i=n(28453);const r={slug:"/helios/pages/todo",custom_edit_url:null,toc_max_heading_level:4,keywords:["doxygen","reference","page"]},t="Todo List",a={},c=[];function l(e){const s={a:"a",dd:"dd",div:"div",dl:"dl",dt:"dt",h1:"h1",header:"header",hr:"hr",p:"p",...(0,i.R)(),...e.components};return(0,o.jsxs)(s.div,{className:"doxyPage",children:["\n",(0,o.jsx)(s.header,{children:(0,o.jsx)(s.h1,{id:"todo-list",children:"Todo List"})}),"\n",(0,o.jsxs)(s.dl,{className:"doxyVariableList",children:["\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/app/application/#aec579824c0704542d3f7d6c4f47851a1",children:"helios::app::Application::~Application"}),"  ()=default"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000005"}),"free resource allocations from renderingDevice, window and InputManager"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Class ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/core/spatial/transform",children:"helios::core::spatial::Transform"})]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000006"}),"use quaternions for rotation"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/engine/builder/gameobject/gameobjectfactory/#a397b02576652662326a68bf15612309a",children:"helios::engine::builder::gameObject::GameObjectFactory::from"}),"  (",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/engine/ecs/gameobject",children:"helios::engine::ecs::GameObject"})," *gameObject)"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000007"}),"Optional ClonePolicy where rules are specified?"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/engine/mechanics/bounds/systems/levelboundsbehaviorsystem/#ac1e97cde1b5f98aaec15989da6e864ab",children:"helios::engine::mechanics::bounds::systems::LevelBoundsBehaviorSystem::update"}),"  (",(0,o.jsx)(s.a,{href:"/docs/helios/structs/helios/engine/runtime/world/updatecontext",children:"helios::engine::runtime::world::UpdateContext"})," &updateContext) noexcept override"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000008"}),"optimize"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/engine/mechanics/input/systems/twinstickinputsystem/#acca47c4456273d89230d78679270eef9",children:"helios::engine::mechanics::input::systems::TwinStickInputSystem::update"}),"  (",(0,o.jsx)(s.a,{href:"/docs/helios/structs/helios/engine/runtime/world/updatecontext",children:"helios::engine::runtime::world::UpdateContext"})," &updateContext) noexcept override"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000009"}),"DO NOT POST IF input is already inactive in shootComponent and no input was detected (after normalizing)"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/engine/mechanics/spawn/systems/gameobjectspawnsystem/#a69d47de2e4bae743dab2fc03349b3902",children:"helios::engine::mechanics::spawn::systems::GameObjectSpawnSystem::update"}),"  (",(0,o.jsx)(s.a,{href:"/docs/helios/structs/helios/engine/runtime/world/updatecontext",children:"helios::engine::runtime::world::UpdateContext"})," &updateContext) noexcept override"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000010"}),"this should be processed before iterating over all schedulers: A scheduler owns the rule, hence a rule that triggered the event's can be associated with the owning Scheduler, making it unneccesary to iterate over already processed events"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Namespace ",(0,o.jsx)(s.a,{href:"/docs/helios/namespaces/helios/engine/modules/effects/gfx/components",children:"helios::engine::modules::effects::gfx::components"})]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000011"}),"move to spatial or effects"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Namespace ",(0,o.jsx)(s.a,{href:"/docs/helios/namespaces/helios/engine/modules/spatial/transform/components",children:"helios::engine::modules::spatial::transform::components"})]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000013"}),"move to spatial transform"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Class ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/engine/runtime/pooling/gameobjectpool",children:"helios::engine::runtime::pooling::GameObjectPool"})]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000014"}),"Prevent duplicate Guids from being added to the pool."]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/engine/runtime/world/gameworld/#a6901bdce0c643c7586dc14697e498b7d",children:"helios::engine::runtime::world::GameWorld::clone"}),"  (const ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/engine/ecs/gameobject",children:"helios::engine::ecs::GameObject"})," &gameObject)"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000016"}),"Optional ClonePolicy where rules are specified?"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/engine/tooling/framepacer/#ac6b55e3ef2b685222358c14e69e89f06",children:"helios::engine::tooling::FramePacer::sync"}),"  ()"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000017"}),"Implement hybrid spinning for the last millisecond of the wait time to improve timing precision and mitigate OS scheduler wake-up latency."]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/event/basiceventmanager/#a572c4c66409151b16992008849d9bbe6",children:"helios::event::BasicEventManager::post"}),"  (std::unique_ptr< const Event > event, ",(0,o.jsx)(s.a,{href:"/docs/helios/namespaces/helios/event/#a68d7042f97d91ed8414724453213e7f0",children:"PostPolicy"})," policy, const std::function< bool(const std::unique_ptr< const Event > &event, const std::unique_ptr< const Event > &evt)> &func) override"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000018"}),"use hashmap instead of queue for faster lookup"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Class ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/event/event",children:"helios::event::Event"})]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000019"}),"can we reset the value for Guids in between frames, if events are guaranteed to be dispatched and processed in between frames?"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Class ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/ext/glfw/window/glfwwindow",children:"helios::ext::glfw::window::GLFWWindow"})]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000001"}),"add glfwSetWindowRefreshCallback"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/ext/opengl/rendering/model/openglmesh/#a2d4c0ccf2f175ce3ac7dddc9bd7c808f",children:"helios::ext::opengl::rendering::model::OpenGLMesh::OpenGLMesh"}),"  (std::shared_ptr< const std::vector< helios::rendering::Vertex > > vertices, std::shared_ptr< const std::vector< unsigned int > > indices, std::shared_ptr< const helios::rendering::model::config::MeshConfig > meshConfig)"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000002"}),"this should not be part of the constructor, instead, lazy init in render pass, then reuse."]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/ext/opengl/rendering/model/openglmesh/#a4118cd59bc33ae54ff8abb339cd67fc9",children:"helios::ext::opengl::rendering::model::OpenGLMesh::OpenGLMesh"}),"  (const ",(0,o.jsx)(s.a,{href:"/docs/helios/structs/helios/rendering/asset/shape/shape",children:"helios::rendering::asset::shape::Shape"})," &shape, std::shared_ptr< const helios::rendering::model::config::MeshConfig > meshConfig)"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000003"}),"this should not be part of the constructor, instead, lazy init in render pass, then reuse."]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/ext/opengl/rendering/opengldevice/#aa97dd0a5a8fb57989616b7fac5139f8b",children:"helios::ext::opengl::rendering::OpenGLDevice::init"}),"  () override"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000004"}),"Provide abstraction for glfwGetProcAddress."]})}),"\n",(0,o.jsxs)(s.dt,{children:["Class ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/input/inputsnapshot",children:"helios::input::InputSnapshot"})]}),"\n",(0,o.jsxs)(s.dd,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000020"}),"Extend to support multiple gamepads, keyboard, and mouse input."]}),"\n",(0,o.jsx)(s.p,{children:"Add timestamp to enable precise replay and network synchronization."}),"\n"]}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/structs/helios/math/mat4/#a11484773381edf083309360d6c940d3f",children:"helios::math::mat4< T >::same"}),"  (const mat4< T > &rgt) const"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000021"}),"account for abs (values close to zero) and rel (larger values), move EPSILON to global constant"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/structs/helios/math/vec2/#a14a40e171d65f8df56deab0b80a6c800",children:"helios::math::vec2< T >::same"}),"  (const vec2< T > &rgt, T epsilon=0.0001) const"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000022"}),"account for abs (values close to zero) and rel (larger values), move epsilon to global constant?"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/structs/helios/math/vec3/#a38d076eec3ebd34f4353d99e3f58ad1e",children:"helios::math::vec3< T >::same"}),"  (const vec3< T > &rgt, T epsilon=0.0001) const"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000023"}),"account for abs (values close to zero) and rel (larger values), move epsilon to global constant?"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/model/mesh/#abd79cc39a499bd1b368afd4dd534b00b",children:"helios::rendering::model::Mesh::init"}),"  ()=0"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000024"})," std::shared_ptr<const std::vector<Texture>> textures_;"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/renderpassfactory/#a18d1346e8e3c78358ccb1872da3125a3",children:"helios::rendering::RenderPassFactory::makeRenderCommand"}),"  (const ",(0,o.jsx)(s.a,{href:"/docs/helios/structs/helios/scene/snapshotitem",children:"helios::scene::SnapshotItem"})," &snapshotItem) const noexcept"]}),"\n",(0,o.jsxs)(s.dd,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000025"}),"future versions might want to use a FactoryMethod in ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/rendercommand",children:"RenderCommand"})," that takes a SnapshotItem and creates a ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/rendercommand",children:"RenderCommand"})," from it (e.g. `RenderCommand::fromSnapshotItem()`); or a Factory `RenderCommandBuilder()` with fluent configuration `.withShader().withMesh().build();`"]}),"\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000026"}),"when batching is implemented, this could be refactored out of this factory method"]}),"\n"]}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/renderqueue/#ace107c45024c29efc237107e3307c2ab",children:"helios::rendering::RenderQueue::add"}),"  (std::unique_ptr< const helios::rendering::RenderCommand > renderCommand)"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000027"}),"prevent adding renderables while rendering"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/renderqueue/#a2d14f75f8f57728f71608dbfde485d80",children:"helios::rendering::RenderQueue::clear"}),"  ()"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000028"}),"strategy to decide whether shrink_to_fit should only be applied if expected numbers RenderCommands for the subsequent render passes is less than current size?"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Class ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/rendertarget",children:"helios::rendering::RenderTarget"})]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000029"}),"This implementation currently represents only the **default framebuffer**. Future extensions should allow it to represent arbitrary framebuffer objects (FBOs), using indices."]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/rendertarget/#a65cfc3bea57ac3b5eb398c85754dc049",children:"helios::rendering::RenderTarget::setSize"}),"  (unsigned int width, unsigned int height) noexcept"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000031"}),"A LayoutManager could be introduced to manage the arrangement of multiple viewports."]})}),"\n",(0,o.jsxs)(s.dt,{children:["Class ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/shader/uniformvaluemap",children:"helios::rendering::shader::UniformValueMap"})]}),"\n",(0,o.jsxs)(s.dd,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000032"}),"UniformMap must allow only one index for all data structures, i.e. if map_[semantics] contains a mat4f, other types should not be allowed for the same semantics."]}),"\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000033"}),"UniformValueMaps should be scoped, e.g. per frame (world matrix, projection, view...), per material (colors, emissive...), per object (world matrix...), which allows for better handling of assigning uniforms: per-frame values change once per frame, while per-object values change per object."]}),"\n"]}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/viewport/#a9c8ed040c0e35728770ddd462860c5bc",children:"helios::rendering::Viewport::setRenderTarget"}),"  (const ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/rendertarget",children:"helios::rendering::RenderTarget"})," *renderTarget, ",(0,o.jsx)(s.a,{href:"/docs/helios/structs/helios/rendering/viewportkey",children:"ViewportKey"})," key) noexcept"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000034"}),"The ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/viewport",children:"Viewport"})," should observe the ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/rendering/rendertarget",children:"RenderTarget"})," for state changes (e.g., resize)."]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/scene/camerascenenode/#ad57acd6f8c8b2e6b02707ba1424377cb",children:"helios::scene::CameraSceneNode::lookAt"}),"  (",(0,o.jsx)(s.a,{href:"/docs/helios/namespaces/helios/math/#a71f1e40e636f47229c3122bdb63099d5",children:"helios::math::vec3f"})," target, ",(0,o.jsx)(s.a,{href:"/docs/helios/namespaces/helios/math/#a71f1e40e636f47229c3122bdb63099d5",children:"helios::math::vec3f"})," up)"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000035"}),"add support for different rotations"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Class ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/scene/frustumcullingstrategy",children:"helios::scene::FrustumCullingStrategy"})]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000036"}),'The returned list should be considered "as is" for now: Each entry in the list is a single renderable entity to consider. Its child nodes (i.e. the sub tree for which this node is the root) should _not_ be automatically considered for rendering. Later iterations should probably use an individual struct that provides a hint whether for a given node a whole subtree should be considered, saving time for culling and memory when constructing the list.']})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/scene/scene/#ab3ad742392c2a2b159cf8927ee6cf375",children:"helios::scene::Scene::createSnapshot"}),"  (const std::shared_ptr< const rendering::Viewport > &viewport) const"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000038"}),"This should be refactored into a factory to prevent domain leakage between ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/scene/scene",children:"Scene"})," and Rendering."]})}),"\n",(0,o.jsxs)(s.dt,{children:["Member ",(0,o.jsx)(s.a,{href:"/docs/helios/classes/helios/scene/scenenode/#a316494fedf68d4ca53cd4453885e0b07",children:"helios::scene::SceneNode::SceneNode"}),"  () noexcept"]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000039"}),"explicitly implement move (assignment) constructor if required, since we have deleted the copy constructors"]})}),"\n",(0,o.jsxs)(s.dt,{children:["Struct ",(0,o.jsx)(s.a,{href:"/docs/helios/structs/helios/scene/snapshotitem",children:"helios::scene::SnapshotItem"})]}),"\n",(0,o.jsx)(s.dd,{children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{id:"_todo000040"}),"we're intentionally preferring stability over performance by using weak_ptr instead of raw pointers. This leaves room for (performance) improvements in later iterations. The Renderable as a weak pointer can later on be further implemented into a pure DTO, storing only scalar values that get send directly to the underlying rendering backend (e.g. vaos, vbos etc.)."]})}),"\n"]}),"\n",(0,o.jsx)(s.hr,{}),"\n",(0,o.jsxs)(s.p,{className:"doxyGeneratedBy",children:["Generated via ",(0,o.jsx)(s.a,{href:"https://xpack.github.io/doxygen2docusaurus",children:"doxygen2docusaurus"})," 2.0.0 by ",(0,o.jsx)(s.a,{href:"https://www.doxygen.nl",children:"Doxygen"})," 1.15.0."]}),"\n"]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);