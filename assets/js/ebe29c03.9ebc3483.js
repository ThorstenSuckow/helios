"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[91200],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>t});var a=s(96540);const d={},i=a.createContext(d);function r(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:r(e.components),a.createElement(i.Provider,{value:n},e.children)}},55360:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>m,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"core-concepts/command-system","title":"Command System","description":"Command pattern implementation with CommandBuffer, Dispatchers, and Manager integration for deferred action execution.","source":"@site/docs/core-concepts/command-system.md","sourceDirName":"core-concepts","slug":"/core-concepts/command-system","permalink":"/docs/core-concepts/command-system","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/command-system.md","tags":[{"inline":true,"label":"gameplay","permalink":"/docs/tags/gameplay"},{"inline":true,"label":"architecture","permalink":"/docs/tags/architecture"},{"inline":true,"label":"commands","permalink":"/docs/tags/commands"}],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Command System","description":"Command pattern implementation with CommandBuffer, Dispatchers, and Manager integration for deferred action execution.","slug":"/core-concepts/command-system","sidebar_label":"Command System","sidebar_position":5,"tags":["gameplay","architecture","commands"],"keywords":["helios","command pattern","CommandBuffer","dispatcher","manager","deferred execution"]},"sidebar":"tutorialSidebar","previous":{"title":"GameObject Builder","permalink":"/docs/core-concepts/gameobject-builder"},"next":{"title":"Event System","permalink":"/docs/core-concepts/event-system"}}');var d=s(74848),i=s(28453);const r={title:"Command System",description:"Command pattern implementation with CommandBuffer, Dispatchers, and Manager integration for deferred action execution.",slug:"/core-concepts/command-system",sidebar_label:"Command System",sidebar_position:5,tags:["gameplay","architecture","commands"],keywords:["helios","command pattern","CommandBuffer","dispatcher","manager","deferred execution"]},t="Command System",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Command Types",id:"command-types",level:2},{value:"TargetedCommand",id:"targetedcommand",level:3},{value:"WorldCommand",id:"worldcommand",level:3},{value:"CommandBuffer",id:"commandbuffer",level:2},{value:"Adding Commands",id:"adding-commands",level:3},{value:"Flushing Commands",id:"flushing-commands",level:3},{value:"Dispatchers",id:"dispatchers",level:2},{value:"Registering Dispatchers",id:"registering-dispatchers",level:3},{value:"Dispatch Flow",id:"dispatch-flow",level:3},{value:"Managers",id:"managers",level:2},{value:"Manager Lifecycle",id:"manager-lifecycle",level:3},{value:"Registration",id:"registration",level:3},{value:"Game Loop Integration",id:"game-loop-integration",level:2},{value:"Key Points",id:"key-points",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Command Design",id:"command-design",level:3},{value:"Dispatcher Usage",id:"dispatcher-usage",level:3},{value:"Manager Integration",id:"manager-integration",level:3},{value:"Related Modules",id:"related-modules",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.header,{children:(0,d.jsx)(n.h1,{id:"command-system",children:"Command System"})}),"\n",(0,d.jsx)(n.p,{children:"This document describes the Command pattern implementation in helios, including command buffering, dispatching, and integration with the game loop."}),"\n",(0,d.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,d.jsxs)(n.p,{children:["The Command System provides a mechanism for ",(0,d.jsx)(n.strong,{children:"deferred action execution"}),". Instead of immediately modifying game state, actions are encapsulated as Command objects, buffered, and executed in a controlled batch during the game loop. This decouples input handling from action processing and enables deterministic, reproducible game logic."]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Input System   \u2502\u2500\u2500\u2500\u2500>\u2502  CommandBuffer  \u2502\u2500\u2500\u2500\u2500>\u2502    GameWorld    \u2502\n\u2502  (produces)     \u2502     \u2502  (queues)       \u2502     \u2502  (receives)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u2502 flush()\n                              \u25bc\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502   Dispatchers   \u2502\n                        \u2502   (route)       \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502    Managers     \u2502\n                        \u2502   (execute)     \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,d.jsx)(n.h2,{id:"command-types",children:"Command Types"}),"\n",(0,d.jsx)(n.h3,{id:"targetedcommand",children:"TargetedCommand"}),"\n",(0,d.jsxs)(n.p,{children:["A ",(0,d.jsx)(n.code,{children:"TargetedCommand"})," operates on a ",(0,d.jsx)(n.strong,{children:"specific entity"})," identified by its ",(0,d.jsx)(n.code,{children:"EntityHandle"}),". Use this for per-entity actions like movement, attacks, or state changes."]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"class MoveCommand : public TargetedCommand {\n    helios::math::vec3f direction_;\n    float speed_;\n    \npublic:\n    MoveCommand(helios::math::vec3f dir, float speed)\n        : direction_(dir), speed_(speed) {}\n\n    void execute(helios::engine::ecs::GameObject entity) const noexcept override {\n        auto* move = entity.get<Move2DComponent>();\n        if (move) {\n            move->setMoveIntent(direction_, speed_);\n        }\n    }\n};\n"})}),"\n",(0,d.jsx)(n.h3,{id:"worldcommand",children:"WorldCommand"}),"\n",(0,d.jsxs)(n.p,{children:["A ",(0,d.jsx)(n.code,{children:"WorldCommand"})," operates on the ",(0,d.jsx)(n.strong,{children:"entire GameWorld"})," rather than a specific entity. Use this for global actions like spawning entities, level transitions, or world-wide effects."]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"class SpawnEnemyCommand : public WorldCommand {\n    helios::math::vec3f position_;\n    \npublic:\n    explicit SpawnEnemyCommand(helios::math::vec3f pos) : position_(pos) {}\n\n    void execute(helios::engine::runtime::world::GameWorld& world) const noexcept override {\n        auto enemy = world.addGameObject();\n        enemy.add<Move2DComponent>(5.0f);\n        enemy.add<TranslationStateComponent>(position_);\n        enemy.setActive(true);\n    }\n};\n"})}),"\n",(0,d.jsx)(n.h2,{id:"commandbuffer",children:"CommandBuffer"}),"\n",(0,d.jsxs)(n.p,{children:["The ",(0,d.jsx)(n.code,{children:"CommandBuffer"})," is a queue that collects commands during the frame and executes them in batch via ",(0,d.jsx)(n.code,{children:"flush()"}),"."]}),"\n",(0,d.jsx)(n.h3,{id:"adding-commands",children:"Adding Commands"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"CommandBuffer cmdBuffer;\n\n// Add a TargetedCommand (requires Guid)\ncmdBuffer.add<MoveCommand>(player.guid(), direction, speed);\n\n// Add a WorldCommand\ncmdBuffer.add<SpawnEnemyCommand>(spawnPosition);\n"})}),"\n",(0,d.jsx)(n.h3,{id:"flushing-commands",children:"Flushing Commands"}),"\n",(0,d.jsxs)(n.p,{children:["During ",(0,d.jsx)(n.code,{children:"flush()"}),", commands are executed in a defined order:"]}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"WorldCommands"})," are processed first (global state changes)"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"TargetedCommands"})," are processed second (per-entity changes)"]}),"\n"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"// At end of input phase or before simulation\ncmdBuffer.flush(gameWorld);\n"})}),"\n",(0,d.jsx)(n.p,{children:"After flush, the buffer is automatically cleared."}),"\n",(0,d.jsx)(n.h2,{id:"dispatchers",children:"Dispatchers"}),"\n",(0,d.jsxs)(n.p,{children:["Dispatchers enable the ",(0,d.jsx)(n.strong,{children:"Visitor pattern"})," for type-safe command routing. Instead of executing commands directly, dispatchers route them to specialized handlers (e.g., Managers)."]}),"\n",(0,d.jsx)(n.h3,{id:"registering-dispatchers",children:"Registering Dispatchers"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"// Create a typed dispatcher for DespawnCommand\nclass DespawnDispatcher : public TypedWorldCommandDispatcher<DespawnCommand> {\n    SpawnManager& manager_;\npublic:\n    explicit DespawnDispatcher(SpawnManager& mgr) : manager_(mgr) {}\n\n    void dispatchTyped(GameWorld& world, const DespawnCommand& cmd) noexcept override {\n        manager_.submit(cmd);\n    }\n};\n\n// Register with CommandBuffer\ncmdBuffer.addDispatcher<DespawnCommand>(\n    std::make_unique<DespawnDispatcher>(spawnManager)\n);\n"})}),"\n",(0,d.jsx)(n.h3,{id:"dispatch-flow",children:"Dispatch Flow"}),"\n",(0,d.jsxs)(n.p,{children:["When ",(0,d.jsx)(n.code,{children:"flush()"})," encounters a command with a registered dispatcher:"]}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsxs)(n.li,{children:["The command's ",(0,d.jsx)(n.code,{children:"accept()"})," method is called with the dispatcher"]}),"\n",(0,d.jsxs)(n.li,{children:["The dispatcher's ",(0,d.jsx)(n.code,{children:"dispatch()"})," method receives the command"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"TypedDispatcher"})," downcasts and calls ",(0,d.jsx)(n.code,{children:"dispatchTyped()"})," with full type info"]}),"\n"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"Command.accept(dispatcher)\n    \u2502\n    \u25bc\nDispatcher.dispatch(command)\n    \u2502\n    \u25bc\nTypedDispatcher.dispatchTyped(typedCommand)\n    \u2502\n    \u25bc\nManager.queueRequest(...)\n"})}),"\n",(0,d.jsx)(n.h2,{id:"managers",children:"Managers"}),"\n",(0,d.jsx)(n.p,{children:"Managers handle cross-cutting concerns that require deferred or batched processing. Commands route to Managers via Dispatchers."}),"\n",(0,d.jsx)(n.h3,{id:"manager-lifecycle",children:"Manager Lifecycle"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"class SpawnManager : public Manager, public SpawnCommandHandler {\n    std::vector<SpawnCommand> spawnCommands_;\n    std::vector<DespawnCommand> despawnCommands_;\n\npublic:\n    bool submit(const SpawnCommand& cmd) noexcept override {\n        spawnCommands_.push_back(cmd);\n        return true;\n    }\n\n    bool submit(const DespawnCommand& cmd) noexcept override {\n        despawnCommands_.push_back(cmd);\n        return true;\n    }\n\n    // Called after CommandBuffer::flush()\n    void flush(GameWorld& world, UpdateContext& ctx) noexcept override {\n        for (const auto& cmd : spawnCommands_) {\n            // Acquire from pool and initialize\n        }\n        for (const auto& cmd : despawnCommands_) {\n            // Return to pool\n        }\n        spawnCommands_.clear();\n        despawnCommands_.clear();\n    }\n};\n"})}),"\n",(0,d.jsx)(n.h3,{id:"registration",children:"Registration"}),"\n",(0,d.jsx)(n.p,{children:"Managers are registered with the GameWorld:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"auto spawnManager = std::make_unique<SpawnManager>();\ngameWorld.addManager(std::move(spawnManager));\n"})}),"\n",(0,d.jsx)(n.h2,{id:"game-loop-integration",children:"Game Loop Integration"}),"\n",(0,d.jsxs)(n.p,{children:["The Command System integrates with the Phase/Pass game loop architecture. Commands can be added during ",(0,d.jsx)(n.strong,{children:"any phase"}),", and are flushed at each ",(0,d.jsx)(n.strong,{children:"Phase Commit"}),"."]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                            FRAME                                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                     \u2502\n\u2502  PRE PHASE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500   \u2502\n\u2502    Pass 1 (Input): Systems read input, add Commands                 \u2502\n\u2502        cmdBuffer.add<MoveCommand>(guid, dir, spd);                  \u2502\n\u2502    Pass 2, Pass 3, ...                                              \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Phase Commit    \u2502\n\u2502       \u2502  1. phaseEventBus.swapBuffers()                             \u2502\n\u2502       \u2502  2. passEventBus.clearAll()                                 \u2502\n\u2502       \u2502  3. commandBuffer.flush()      \u25c4\u2500\u2500 Commands execute here    \u2502\n\u2502       \u2502  4. gameWorld.flushManagers()  \u25c4\u2500\u2500 Managers process queues  \u2502\n\u2502       \u25bc                                                             \u2502\n\u2502  MAIN PHASE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500   \u2502\n\u2502    Pass 1 (Gameplay): Movement, Physics systems                     \u2502\n\u2502    Pass 2 (Collision): Collision detection                          \u2502\n\u2502           Pass 2 commit!                                            \u2502\n\u2502    Pass 3 (AI): AI systems                                          \u2502\n\u2502           (Access to events from Pass 1/2                           \u2502\n\u2502           due to Pass 2 commit)                                     \u2502\n\u2502        Commands can still be added here!                            \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Phase Commit    \u2502\n\u2502       \u2502  commandBuffer.flush() + gameWorld.flushManagers()          \u2502\n\u2502       \u25bc                                                             \u2502\n\u2502  POST PHASE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500   \u2502\n\u2502    Pass 1 (Scene Sync): Sync transforms to scene graph              \u2502\n\u2502    Pass 2 (Cleanup): Clear dirty flags                              \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Phase Commit    \u2502\n\u2502       \u2502  commandBuffer.flush() + gameWorld.flushManagers()          \u2502\n\u2502       \u25bc                                                             \u2502\n\u2502                          RENDER                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,d.jsx)(n.h3,{id:"key-points",children:"Key Points"}),"\n",(0,d.jsxs)(n.p,{children:["Commands are ",(0,d.jsx)(n.strong,{children:"not"})," limited to the Pre Phase. Systems in any phase can add commands:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"void update(UpdateContext& ctx) noexcept override {\n    // Add command during any phase\n    ctx.commandBuffer().add<DespawnCommand>(entity.guid(), poolId);\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:"At each Phase Commit, the following sequence occurs:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"// Phase Commit sequence\nphaseEventBus.swapBuffers();    // Phase events become readable\npassEventBus.clearAll();         // Pass events are cleared\ncommandBuffer.flush();           // Commands execute (world mutations)\ngameWorld.flushManagers();       // Managers process queued requests\n"})}),"\n",(0,d.jsx)(n.p,{children:"This means spawns and despawns triggered in one phase are visible to systems in the next phase."}),"\n",(0,d.jsxs)(n.p,{children:["For detailed phase/pass event handling, see ",(0,d.jsx)(n.a,{href:"/docs/core-concepts/gameloop-architecture",children:"Game Loop Architecture"}),"."]}),"\n",(0,d.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,d.jsx)(n.h3,{id:"command-design",children:"Command Design"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["Commands should be ",(0,d.jsx)(n.strong,{children:"immutable"})," after construction"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"execute()"})," must be ",(0,d.jsx)(n.strong,{children:"noexcept"})," - handle errors internally"]}),"\n",(0,d.jsxs)(n.li,{children:["Keep commands ",(0,d.jsx)(n.strong,{children:"lightweight"})," - store only essential data"]}),"\n",(0,d.jsxs)(n.li,{children:["Use ",(0,d.jsx)(n.code,{children:"WorldCommand"})," for spawning; use ",(0,d.jsx)(n.code,{children:"TargetedCommand"})," for entity mutations"]}),"\n"]}),"\n",(0,d.jsx)(n.h3,{id:"dispatcher-usage",children:"Dispatcher Usage"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["Register dispatchers for commands that require ",(0,d.jsx)(n.strong,{children:"external handling"})]}),"\n",(0,d.jsxs)(n.li,{children:["Use dispatchers to route to ",(0,d.jsx)(n.strong,{children:"Managers"})," for pooled entity lifecycle"]}),"\n",(0,d.jsxs)(n.li,{children:["Direct ",(0,d.jsx)(n.code,{children:"execute()"})," is fine for simple, self-contained commands"]}),"\n"]}),"\n",(0,d.jsx)(n.h3,{id:"manager-integration",children:"Manager Integration"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["Managers ",(0,d.jsx)(n.strong,{children:"queue"})," requests during command dispatch"]}),"\n",(0,d.jsxs)(n.li,{children:["Managers ",(0,d.jsx)(n.strong,{children:"execute"})," requests during ",(0,d.jsx)(n.code,{children:"flushManagers()"})]}),"\n",(0,d.jsx)(n.li,{children:"This ensures all commands are processed before entities are spawned/despawned"}),"\n"]}),"\n",(0,d.jsx)(n.h2,{id:"related-modules",children:"Related Modules"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"helios.engine.runtime.messaging.command.CommandBuffer"})," - Central command queue"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"helios.engine.runtime.messaging.command.TargetedCommand"})," - Per-entity command base"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"helios.engine.runtime.messaging.command.WorldCommand"})," - World-wide command base"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"helios.engine.runtime.messaging.command.TypedTargetedCommandDispatcher"})," - Type-safe entity command dispatch"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"helios.engine.runtime.messaging.command.TypedWorldCommandDispatcher"})," - Type-safe world command dispatch"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"helios.engine.runtime.world.Manager"})," - Base class for deferred processing managers"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"helios.engine.runtime.world.GameWorld"})," - Manager registration and flushing"]}),"\n"]}),"\n",(0,d.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.a,{href:"/docs/core-concepts/event-system",children:"Event System"})," - Phase/pass event propagation"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.a,{href:"/docs/core-concepts/gameloop-architecture",children:"Game Loop Architecture"})," - Overall frame structure"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.a,{href:"/docs/core-concepts/component-system",children:"Component System"})," - GameObject, Component, System architecture"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.a,{href:"/docs/core-concepts/spawn-system",children:"Spawn System"})," - Entity lifecycle with spawn scheduling and pooling"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(l,{...e})}):l(e)}}}]);