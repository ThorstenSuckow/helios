"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[25648],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(96540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}},50201:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"core-concepts/ecs/entity-manager","title":"EntityManager","description":"Central manager for entity lifecycle and component storage in the ECS.","source":"@site/docs/core-concepts/ecs/entity-manager.md","sourceDirName":"core-concepts/ecs","slug":"/core-concepts/ecs/entity-manager","permalink":"/docs/core-concepts/ecs/entity-manager","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/ecs/entity-manager.md","tags":[{"inline":true,"label":"ecs","permalink":"/docs/tags/ecs"},{"inline":true,"label":"architecture","permalink":"/docs/tags/architecture"},{"inline":true,"label":"manager","permalink":"/docs/tags/manager"}],"version":"current","sidebarPosition":2,"frontMatter":{"title":"EntityManager","description":"Central manager for entity lifecycle and component storage in the ECS.","slug":"/core-concepts/ecs/entity-manager","sidebar_label":"EntityManager","sidebar_position":2,"tags":["ecs","architecture","manager"],"keywords":["helios","EntityManager","ECS","component storage","SparseSet"]},"sidebar":"tutorialSidebar","previous":{"title":"GameObject","permalink":"/docs/core-concepts/ecs/gameobject"},"next":{"title":"EntityRegistry","permalink":"/docs/core-concepts/ecs/entity-registry"}}');var s=t(74848),i=t(28453);const a={title:"EntityManager",description:"Central manager for entity lifecycle and component storage in the ECS.",slug:"/core-concepts/ecs/entity-manager",sidebar_label:"EntityManager",sidebar_position:2,tags:["ecs","architecture","manager"],keywords:["helios","EntityManager","ECS","component storage","SparseSet"]},o="EntityManager",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"API Reference",id:"api-reference",level:2},{value:"Entity Operations",id:"entity-operations",level:3},{value:"Creating Entities",id:"creating-entities",level:4},{value:"Destroying Entities",id:"destroying-entities",level:4},{value:"Component Operations",id:"component-operations",level:3},{value:"Emplacing Components",id:"emplacing-components",level:4},{value:"Retrieving Components",id:"retrieving-components",level:4},{value:"Removing Components",id:"removing-components",level:4},{value:"Component Queries",id:"component-queries",level:3},{value:"Enable/Disable Components",id:"enabledisable-components",level:3},{value:"Entity Cloning",id:"entity-cloning",level:3},{value:"SparseSet Access",id:"sparseset-access",level:3},{value:"Component Storage",id:"component-storage",level:2},{value:"Memory Layout",id:"memory-layout",level:3},{value:"Lifecycle Hook Integration",id:"lifecycle-hook-integration",level:2},{value:"Capacity and Performance",id:"capacity-and-performance",level:2},{value:"Thread Safety",id:"thread-safety",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Example: System Implementation",id:"example-system-implementation",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"entitymanager",children:"EntityManager"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"EntityManager"})," is the central hub for entity lifecycle management and component storage in the helios ECS. It coordinates between the ",(0,s.jsx)(n.code,{children:"EntityRegistry"})," (handle allocation) and type-specific ",(0,s.jsx)(n.code,{children:"SparseSet"})," containers (component data)."]}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"EntityManager"})," provides a unified interface for:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Entity Creation/Destruction"})," - Delegates handle management to ",(0,s.jsx)(n.code,{children:"EntityRegistry"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Component Storage"})," - Maintains type-indexed ",(0,s.jsx)(n.code,{children:"SparseSet"})," containers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Component Operations"})," - Emplace, retrieve, remove, and query components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Entity Cloning"})," - Deep-copy all components from one entity to another"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"EntityRegistry registry;\nEntityManager manager(registry);\n\n// Create entity\nauto entity = manager.create();\n\n// Add components\nauto* transform = manager.emplace<TransformComponent>(entity, position);\nauto* health = manager.emplace<HealthComponent>(entity, 100.0f);\n\n// Query and retrieve\nif (manager.has<HealthComponent>(entity)) {\n    auto* hp = manager.get<HealthComponent>(entity);\n}\n\n// Remove component\nmanager.remove<HealthComponent>(entity);\n\n// Destroy entity (removes all components)\nmanager.destroy(entity);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        EntityManager                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  EntityRegistry  \u2502     \u2502  components_ (vector)            \u2502  \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502     \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502  \u2502\n\u2502  \u2502  \u2502VersionId[] \u2502  \u2502     \u2502  \u2502 [0] SparseSet<Transform>    \u2502 \u2502  \u2502\n\u2502  \u2502  \u2502 FreeList   \u2502  \u2502     \u2502  \u2502 [1] SparseSet<Health>       \u2502 \u2502  \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502     \u2502  \u2502 [2] SparseSet<Renderable>   \u2502 \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502  \u2502 [3] nullptr                 \u2502 \u2502  \u2502\n\u2502          \u2502                \u2502  \u2502 [4] SparseSet<Collision>    \u2502 \u2502  \u2502\n\u2502          \u25bc                \u2502  \u2502 ...                         \u2502 \u2502  \u2502\n\u2502    Handle Validation      \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502  \u2502\n\u2502    Create / Destroy       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                        \u2502                        \u2502\n\u2502                                        \u25bc                        \u2502\n\u2502                               Component Storage                 \u2502\n\u2502                               (indexed by TypeId)               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,s.jsx)(n.h3,{id:"entity-operations",children:"Entity Operations"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Method"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"create()"})}),(0,s.jsxs)(n.td,{children:["Creates a new entity, returns ",(0,s.jsx)(n.code,{children:"EntityHandle"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"destroy(handle)"})}),(0,s.jsx)(n.td,{children:"Destroys entity and invalidates handle"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"isValid(handle)"})}),(0,s.jsx)(n.td,{children:"Checks if handle points to living entity"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"handle(entityId)"})}),(0,s.jsx)(n.td,{children:"Reconstructs handle from entity ID"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"creating-entities",children:"Creating Entities"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto entity = manager.create();\n// entity.entityId = allocated ID\n// entity.version = current version for that slot\n"})}),"\n",(0,s.jsx)(n.h4,{id:"destroying-entities",children:"Destroying Entities"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"bool destroyed = manager.destroy(entity);\n// Returns false if entity was already invalid\n"})}),"\n",(0,s.jsx)(n.h3,{id:"component-operations",children:"Component Operations"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Method"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"emplace<T>(handle, args...)"})}),(0,s.jsx)(n.td,{children:"Constructs component in-place"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"emplaceOrGet<T>(handle, args...)"})}),(0,s.jsx)(n.td,{children:"Returns existing or creates new"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"get<T>(handle)"})}),(0,s.jsx)(n.td,{children:"Returns pointer or nullptr"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"has<T>(handle)"})}),(0,s.jsx)(n.td,{children:"Checks component existence"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"has(handle, typeId)"})}),(0,s.jsx)(n.td,{children:"Runtime type ID version"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"remove<T>(handle)"})}),(0,s.jsx)(n.td,{children:"Removes component from entity"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"raw(handle, typeId)"})}),(0,s.jsx)(n.td,{children:"Returns void* to component data"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"emplacing-components",children:"Emplacing Components"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Construct with arguments\nauto* transform = manager.emplace<TransformComponent>(entity, position, rotation);\n\n// Returns nullptr if component already exists\nauto* duplicate = manager.emplace<TransformComponent>(entity);  // nullptr!\n\n// Use emplaceOrGet for upsert behavior\nauto* existing = manager.emplaceOrGet<TransformComponent>(entity);\n"})}),"\n",(0,s.jsx)(n.h4,{id:"retrieving-components",children:"Retrieving Components"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Type-safe retrieval\nauto* health = manager.get<HealthComponent>(entity);\nif (health) {\n    health->takeDamage(10.0f);\n}\n\n// Raw pointer access (for reflection/serialization)\nvoid* raw = manager.raw(entity, typeId);\n"})}),"\n",(0,s.jsx)(n.h4,{id:"removing-components",children:"Removing Components"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"bool removed = manager.remove<HealthComponent>(entity);\n// Returns false if:\n// - Entity invalid\n// - Component not attached\n// - onRemove() returned false\n"})}),"\n",(0,s.jsx)(n.h3,{id:"component-queries",children:"Component Queries"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Check single component\nif (manager.has<HealthComponent>(entity)) { ... }\n\n// Iterate all component types on entity\nfor (auto typeId : manager.componentTypeIds(entity)) {\n    void* component = manager.raw(entity, typeId);\n    // Process component...\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"enabledisable-components",children:"Enable/Disable Components"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Enable specific component\nmanager.enable(entity, typeId);\n\n// Disable specific component\nmanager.disable(entity, typeId);\n\n// With explicit flag\nmanager.enable(entity, typeId, false);  // Same as disable\n"})}),"\n",(0,s.jsx)(n.h3,{id:"entity-cloning",children:"Entity Cloning"}),"\n",(0,s.jsx)(n.p,{children:"Clone all components from one entity to another:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto source = manager.create();\nmanager.emplace<TransformComponent>(source, position);\nmanager.emplace<HealthComponent>(source, 100.0f);\n\nauto target = manager.create();\nmanager.clone(source, target);\n// target now has copies of all source's components\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Cloning uses the ",(0,s.jsx)(n.code,{children:"ComponentOps::clone"})," function pointer, which:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Invokes the copy constructor"}),"\n",(0,s.jsxs)(n.li,{children:["Calls ",(0,s.jsx)(n.code,{children:"onClone()"})," if the component implements it"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"sparseset-access",children:"SparseSet Access"}),"\n",(0,s.jsx)(n.p,{children:"For advanced use cases, direct access to the underlying storage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Get typed SparseSet\nauto* transforms = manager.getSparseSet<TransformComponent>();\nif (transforms) {\n    // Iterate all transforms efficiently\n    for (const auto& t : *transforms) {\n        // Process...\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"component-storage",children:"Component Storage"}),"\n",(0,s.jsxs)(n.p,{children:["Components are stored in type-specific ",(0,s.jsx)(n.code,{children:"SparseSet"})," containers:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"std::vector<std::unique_ptr<SparseSetBase>> components_;\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Index"})," = ",(0,s.jsx)(n.code,{children:"ComponentTypeId::id<T>().value()"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Value"})," = ",(0,s.jsx)(n.code,{children:"SparseSet<T>"})," containing all instances of that component type"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lazy allocation"})," - Sets created on first use"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"memory-layout",children:"Memory Layout"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"components_[0] \u2192 SparseSet<TransformComponent>\n                 \u251c\u2500\u2500 sparse_: [_, 0, _, 1, _, 2]  (entityId \u2192 denseIndex)\n                 \u2514\u2500\u2500 storage_: [T\u2081, T\u2084, T\u2086]       (dense, cache-friendly)\n\ncomponents_[1] \u2192 SparseSet<HealthComponent>\n                 \u251c\u2500\u2500 sparse_: [0, _, 1, _]\n                 \u2514\u2500\u2500 storage_: [H\u2081, H\u2083]\n\ncomponents_[2] \u2192 nullptr  (no entities have this type)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"lifecycle-hook-integration",children:"Lifecycle Hook Integration"}),"\n",(0,s.jsx)(n.p,{children:"EntityManager integrates with the lifecycle system:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// On component removal\ntemplate<typename T>\nbool remove(const EntityHandle& handle) {\n    // ...\n    const auto& ops = ComponentOpsRegistry::ops(typeId);\n    \n    // Allow component to intercept removal\n    if (ops.onRemove && !ops.onRemove(rawCmp)) {\n        return false;  // Removal blocked\n    }\n    \n    return sparseSet->remove(handle.entityId);\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"capacity-and-performance",children:"Capacity and Performance"}),"\n",(0,s.jsx)(n.p,{children:"EntityManager is constructed with an initial capacity hint:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"explicit EntityManager(EntityRegistry& registry, \n                       size_t capacity = ENTITY_MANAGER_DEFAULT_CAPACITY);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This capacity is passed to each ",(0,s.jsx)(n.code,{children:"SparseSet"})," to pre-allocate storage, reducing reallocations during gameplay."]}),"\n",(0,s.jsx)(n.h2,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"EntityManager"})," is ",(0,s.jsx)(n.strong,{children:"not thread-safe"}),". All operations must be performed from a single thread or externally synchronized."]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use GameObject for game code"})," - EntityManager is lower-level, prefer ",(0,s.jsx)(n.code,{children:"GameObject"})," facade"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Batch operations"})," - Create/destroy entities in batches when possible"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Check validity"})," - Always verify handles before operations"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Prefer type-safe methods"})," - Use ",(0,s.jsx)(n.code,{children:"get<T>()"})," over ",(0,s.jsx)(n.code,{children:"raw()"})," when type is known"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pre-register component types"})," - Register all types during bootstrap to avoid runtime allocations"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"example-system-implementation",children:"Example: System Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void HealthSystem::update(EntityManager& em, float deltaTime) {\n    auto* healthSet = em.getSparseSet<HealthComponent>();\n    auto* regenSet = em.getSparseSet<HealthRegenComponent>();\n    \n    if (!healthSet || !regenSet) return;\n    \n    for (size_t i = 0; i < healthSet->size(); ++i) {\n        auto entityId = healthSet->entityAt(i);\n        \n        if (regenSet->contains(entityId)) {\n            auto* health = healthSet->get(entityId);\n            auto* regen = regenSet->get(entityId);\n            \n            health->heal(regen->rate() * deltaTime);\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/ecs/gameobject",children:"GameObject"})," - High-level entity wrapper"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/ecs/entity-registry",children:"EntityRegistry"})," - Handle allocation and validation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/ecs/entity-handle",children:"EntityHandle"})," - Versioned entity reference"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/ecs/view",children:"View"})," - Component-based entity queries"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/sparse-set",children:"SparseSet"})," - Underlying storage"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/component-lifecycle",children:"Component Lifecycle"})," - Lifecycle hooks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-concepts/component-registry",children:"Component Registry"})," - Type registration"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);