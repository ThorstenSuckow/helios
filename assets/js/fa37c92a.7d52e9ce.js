"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[11933],{25275:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"core-concepts/component-lifecycle","title":"Component Lifecycle","description":"Lifecycle hooks for ECS components: onAcquire, onRelease, onRemove, enable/disable, and cloning.","source":"@site/docs/core-concepts/component-lifecycle.md","sourceDirName":"core-concepts","slug":"/core-concepts/component-lifecycle","permalink":"/docs/core-concepts/component-lifecycle","draft":false,"unlisted":false,"editUrl":"https://github.com/thorstensuckow/helios/tree/main/website/docs/core-concepts/component-lifecycle.md","tags":[{"inline":true,"label":"ecs","permalink":"/docs/tags/ecs"},{"inline":true,"label":"architecture","permalink":"/docs/tags/architecture"},{"inline":true,"label":"lifecycle","permalink":"/docs/tags/lifecycle"}],"version":"current","sidebarPosition":12,"frontMatter":{"title":"Component Lifecycle","description":"Lifecycle hooks for ECS components: onAcquire, onRelease, onRemove, enable/disable, and cloning.","slug":"/core-concepts/component-lifecycle","sidebar_label":"Component Lifecycle","sidebar_position":12,"tags":["ecs","architecture","lifecycle"],"keywords":["helios","component lifecycle","ECS","hooks","pooling","onAcquire","onRelease"]},"sidebar":"tutorialSidebar","previous":{"title":"Component Registry","permalink":"/docs/core-concepts/component-registry"},"next":{"title":"Overview","permalink":"/docs/examples"}}');var t=o(74848),c=o(28453);const i={title:"Component Lifecycle",description:"Lifecycle hooks for ECS components: onAcquire, onRelease, onRemove, enable/disable, and cloning.",slug:"/core-concepts/component-lifecycle",sidebar_label:"Component Lifecycle",sidebar_position:12,tags:["ecs","architecture","lifecycle"],keywords:["helios","component lifecycle","ECS","hooks","pooling","onAcquire","onRelease"]},l="Component Lifecycle Hooks",r={},a=[{value:"Overview",id:"overview",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Trait Detection",id:"trait-detection",level:2},{value:"Hook Details",id:"hook-details",level:2},{value:"onAcquire / onRelease",id:"onacquire--onrelease",level:3},{value:"onRemove",id:"onremove",level:3},{value:"enable / disable",id:"enable--disable",level:3},{value:"onClone",id:"onclone",level:3},{value:"onActivate / onDeactivate",id:"onactivate--ondeactivate",level:3},{value:"Registration",id:"registration",level:2},{value:"Invocation",id:"invocation",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"component-lifecycle-hooks",children:"Component Lifecycle Hooks"})}),"\n",(0,t.jsxs)(n.p,{children:["The helios ECS provides ",(0,t.jsx)(n.strong,{children:"lifecycle hooks"})," that components can implement to respond to state changes during their lifetime. These hooks are automatically invoked by the engine based on compile-time trait detection."]}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Lifecycle hooks enable components to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reset state"})," when acquired from or released to an object pool"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Intercept removal"})," to prevent destruction or perform cleanup"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"React to enable/disable"})," for runtime activation control"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Initialize after cloning"})," when spawned from prefabs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Respond to activation"})," when GameObjects become active/inactive"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Hook"}),(0,t.jsx)(n.th,{children:"Signature"}),(0,t.jsx)(n.th,{children:"When Called"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"onAcquire"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"void onAcquire()"})}),(0,t.jsx)(n.td,{children:"GameObject acquired from pool"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"onRelease"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"void onRelease()"})}),(0,t.jsx)(n.td,{children:"GameObject returned to pool"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"onRemove"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"bool onRemove()"})}),(0,t.jsx)(n.td,{children:"Before component removal"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"enable"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"void enable()"})}),(0,t.jsxs)(n.td,{children:["Component enabled via ",(0,t.jsx)(n.code,{children:"setActive(true)"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"disable"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"void disable()"})}),(0,t.jsxs)(n.td,{children:["Component disabled via ",(0,t.jsx)(n.code,{children:"setActive(false)"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"onClone"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"void onClone(const T&)"})}),(0,t.jsx)(n.td,{children:"After copy construction during cloning"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"onActivate"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"void onActivate()"})}),(0,t.jsx)(n.td,{children:"GameObject activated"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"onDeactivate"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"void onDeactivate()"})}),(0,t.jsx)(n.td,{children:"GameObject deactivated"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"trait-detection",children:"Trait Detection"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ComponentReflector"})," uses C++20 concepts to detect which hooks a component implements at compile time:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// helios/engine/ecs/Traits.ixx\n\ntemplate<typename T>\nconcept HasOnAcquire = requires(T t) {\n    {t.onAcquire()} -> std::same_as<void>;\n};\n\ntemplate<typename T>\nconcept HasOnRelease = requires(T t) {\n    {t.onRelease()} -> std::same_as<void>;\n};\n\ntemplate<typename T>\nconcept HasOnRemove = requires(T t) {\n    {t.onRemove()} -> std::convertible_to<bool>;\n};\n\ntemplate<typename T>\nconcept HasToogleable = requires(T t) {\n    {t.disable()} -> std::same_as<void>;\n    {t.enable()} -> std::same_as<void>;\n};\n\ntemplate<typename T>\nconcept HasClone = requires(T t, const T& source) {\n    {t.onClone(source)} -> std::same_as<void>;\n};\n\ntemplate<typename T>\nconcept HasActivatable = requires(T t) {\n    {t.onActivate()} -> std::same_as<void>;\n    {t.onDeactivate()} -> std::same_as<void>;\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"hook-details",children:"Hook Details"}),"\n",(0,t.jsx)(n.h3,{id:"onacquire--onrelease",children:"onAcquire / onRelease"}),"\n",(0,t.jsxs)(n.p,{children:["Used by the ",(0,t.jsx)(n.strong,{children:"object pooling system"})," to manage component state when GameObjects are reused."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class HealthComponent {\n    float health_;\n    float maxHealth_;\n\npublic:\n    void onAcquire() noexcept {\n        // Reset to full health when spawned from pool\n        health_ = maxHealth_;\n    }\n\n    void onRelease() noexcept {\n        // Clean up before returning to pool\n        health_ = maxHealth_;\n    }\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Typical use cases:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Reset runtime state (health, timers, counters)"}),"\n",(0,t.jsx)(n.li,{children:"Clear cached references"}),"\n",(0,t.jsx)(n.li,{children:"Reinitialize physics state"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"onremove",children:"onRemove"}),"\n",(0,t.jsxs)(n.p,{children:["Called ",(0,t.jsx)(n.strong,{children:"before"})," a component is removed from an entity. Return ",(0,t.jsx)(n.code,{children:"false"})," to ",(0,t.jsx)(n.strong,{children:"prevent removal"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class PersistentComponent {\npublic:\n    bool onRemove() {\n        if (hasUnsavedData()) {\n            saveData();\n        }\n        return true; // Allow removal\n    }\n};\n\nclass ProtectedComponent {\npublic:\n    bool onRemove() {\n        return false; // Prevent removal\n    }\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"enable--disable",children:"enable / disable"}),"\n",(0,t.jsxs)(n.p,{children:["Called when a GameObject's active state changes via ",(0,t.jsx)(n.code,{children:"setActive()"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class SceneNodeComponent {\n    SceneNode* sceneNode_;\n    bool isEnabled_ = true;\n\npublic:\n    void enable() noexcept {\n        isEnabled_ = true;\n        sceneNode_->setActive(true);\n    }\n\n    void disable() noexcept {\n        isEnabled_ = false;\n        sceneNode_->setActive(false);\n    }\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Important:"})," Both ",(0,t.jsx)(n.code,{children:"enable()"})," and ",(0,t.jsx)(n.code,{children:"disable()"})," must be implemented together (the ",(0,t.jsx)(n.code,{children:"HasToogleable"})," concept requires both)."]}),"\n",(0,t.jsx)(n.h3,{id:"onclone",children:"onClone"}),"\n",(0,t.jsxs)(n.p,{children:["Called ",(0,t.jsx)(n.strong,{children:"after"})," the copy constructor during cloning. Use this for initialization that requires the copy to be complete."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class SceneNodeComponent {\n    SceneNode* sceneNode_;\n\npublic:\n    SceneNodeComponent(const SceneNodeComponent&) = default;\n\n    void onClone(const SceneNodeComponent& source) {\n        // Create a new SceneNode for this clone\n        auto* parent = source.sceneNode_->parent();\n        auto node = std::make_unique<SceneNode>(source.sceneNode_->shareRenderable());\n        sceneNode_ = parent->addNode(std::move(node));\n    }\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Why onClone?"}),(0,t.jsx)(n.br,{}),"\nThe copy constructor should be simple (for ",(0,t.jsx)(n.code,{children:"noexcept"})," move support). Complex cloning logic with side effects belongs in ",(0,t.jsx)(n.code,{children:"onClone()"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"onactivate--ondeactivate",children:"onActivate / onDeactivate"}),"\n",(0,t.jsx)(n.p,{children:"Called when the GameObject's activation state changes. Both methods must be implemented together."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class AIComponent {\npublic:\n    void onActivate() {\n        startBehaviorTree();\n    }\n\n    void onDeactivate() {\n        pauseBehaviorTree();\n    }\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"registration",children:"Registration"}),"\n",(0,t.jsx)(n.p,{children:"Hooks are automatically detected when a component is registered:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// In your module's registry.ixx\ninline void registerComponents() {\n    using R = helios::engine::ecs::ComponentReflector;\n    \n    // Hooks are detected via concepts during registration\n    R::registerType<HealthComponent>();      // Has onAcquire, onRelease\n    R::registerType<SceneNodeComponent>();   // Has enable, disable, onClone\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"invocation",children:"Invocation"}),"\n",(0,t.jsxs)(n.p,{children:["The engine invokes hooks through the ",(0,t.jsx)(n.code,{children:"ComponentOps"})," function pointers:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// GameObject::setActive() calls enable/disable\nvoid setActive(bool active) {\n    for (auto typeId : componentTypeIds()) {\n        const auto ops = ComponentOpsRegistry::ops(typeId);\n        void* raw = entityManager_->raw(entityHandle_, typeId);\n\n        if (active && ops.enable) {\n            ops.enable(raw);\n        } else if (!active && ops.disable) {\n            ops.disable(raw);\n        }\n    }\n}\n\n// GameObject::onAcquire() calls component onAcquire\nvoid onAcquire() {\n    for (auto typeId : componentTypeIds()) {\n        const auto ops = ComponentOpsRegistry::ops(typeId);\n        void* raw = entityManager_->raw(entityHandle_, typeId);\n\n        if (ops.onAcquire) {\n            ops.onAcquire(raw);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Keep hooks lightweight"})," - They are called frequently during pooling and state changes"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["Use ",(0,t.jsx)(n.code,{children:"noexcept"})]})," - Lifecycle hooks should not throw exceptions"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Pair enable/disable"})," - Both must be implemented if either is needed"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Reset in onAcquire"})," - Always reset component state when acquired from pool"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Avoid side effects in copy constructor"})," - Use ",(0,t.jsx)(n.code,{children:"onClone()"})," for complex initialization"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Don't rely on hook order"})," - Components may be processed in any order"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/component-registry",children:"Component Registry"})," - How to register components"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/ecs/gameobject",children:"GameObject"})," - High-level entity wrapper"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/ecs/entity-manager",children:"EntityManager"})," - Low-level entity management"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/component-system",children:"Component System"})," - Component fundamentals"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/sparse-set",children:"Sparse Set"})," - Underlying storage and removal mechanics"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>l});var s=o(96540);const t={},c=s.createContext(t);function i(e){const n=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);