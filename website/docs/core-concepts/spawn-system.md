---
title: Spawn System
description: Entity lifecycle management with spawn scheduling, profiles, behaviors, and pool integration.
slug: /core-concepts/spawn-system
sidebar_label: Spawn System
sidebar_position: 7
tags: [gameplay, architecture, spawn]
keywords: [helios, spawn system, object pooling, entity lifecycle, SpawnManager, SpawnScheduler]
---

<!-- Auto-synced from repository by scripts/sync-changelog.mjs. Do not edit this file directly. -->
# Spawn System

helios provides a comprehensive **spawn system** for managing entity lifecycle at runtime. The system separates concerns into scheduling (when/how many), behavior (where/how), and execution (pool integration).

## Overview

The spawn system consists of several layers working together:

- **SpawnScheduler:** Evaluates rules and determines when spawning should occur
- **SpawnProfile:** Defines how entities are spawned (pool, placer, initializer)
- **SpawnManager:** Processes spawn/despawn commands via pools
- **Commands & Dispatchers:** Route commands through the command pipeline
- **SpawnCommandHandler:** Interface for managers that process spawn commands

```
┌─────────────────────────────────────────────────────────────────────┐
│                         SPAWN PIPELINE                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  POLICY LAYER (when/how many)                                       │
│  ┌─────────────┐    ┌─────────────┐    ┌──────────────┐             │
│  │ SpawnRule   │───>│SpawnCondition───>│AmountProvider│             │
│  └─────────────┘    └─────────────┘    └──────────────┘             │
│         │                                                           │
│         ▼                                                           │
│  SCHEDULING LAYER                                                   │
│  ┌─────────────────────────────────────────┐                        │
│  │           SpawnScheduler                │                        │
│  │  (evaluates rules, produces plans)      │                        │
│  └────────────────────┬────────────────────┘                        │
│                       │                                             │
│                       ▼                                             │
│  COMMAND LAYER                                                      │
│  ┌─────────────────────────────────────────┐                        │
│  │     ScheduledSpawnPlanCommand           │                        │
│  └────────────────────┬────────────────────┘                        │
│                       │                                             │
│                       ▼                                             │
│  EXECUTION LAYER                                                    │
│  ┌─────────────────────────────────────────┐                        │
│  │           SpawnManager                  │                        │
│  │  ┌───────────┐    ┌───────────┐         │                        │
│  │  │SpawnPlacer│    │Initializer│         │                        │
│  │  └───────────┘    └───────────┘         │                        │
│  └─────────────────────────────────────────┘                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

## Key Concepts

### SpawnProfile

A `SpawnProfile` bundles together everything needed to spawn entities of a particular type:

```cpp
import helios.engine.runtime.spawn.SpawnProfile;
import helios.engine.runtime.spawn.behavior.placements.RandomSpawnPlacer;
import helios.engine.runtime.spawn.behavior.initializers.RandomDirectionInitializer;

auto enemyProfile = std::make_unique<SpawnProfile>(SpawnProfile{
    .gameObjectPoolId = enemyPoolId,
    .spawnPlacer = std::make_unique<RandomSpawnPlacer>(),
    .spawnInitializer = std::make_unique<RandomDirectionInitializer>()
});
```

| Field | Purpose |
|-------|---------|
| `gameObjectPoolId` | Which pool to acquire entities from |
| `spawnPlacer` | Strategy for positioning spawned entities |
| `spawnInitializer` | Strategy for initializing entity components |

### SpawnPlacer

Determines **where** entities spawn. Built-in implementations:

| Placer | Behavior |
|--------|----------|
| `RandomSpawnPlacer` | Random position within level bounds |
| `EmitterSpawnPlacer` | At the emitter's current position |

```cpp
class RandomSpawnPlacer : public SpawnPlacer {
public:
    vec3f getPosition(const SpawnContext& ctx) const override {
        const auto& bounds = ctx.level().bounds();
        return vec3f{
            Random::range(bounds.min()[0], bounds.max()[0]),
            Random::range(bounds.min()[1], bounds.max()[1]),
            0.0f
        };
    }
};
```

### SpawnInitializer

Configures spawned entities with initial state. Built-in implementations:

| Initializer | Behavior |
|-------------|----------|
| `EmitterInitializer` | Copies direction/velocity from emitter |
| `RandomDirectionInitializer` | Assigns random 2D direction |

```cpp
class EmitterInitializer : public SpawnInitializer {
public:
    void initialize(GameObject& entity, const SpawnContext& ctx) const override {
        if (const auto& emitter = ctx.emitterContext()) {
            if (auto* dir = entity.get<DirectionComponent>()) {
                dir->setDirection(emitter->direction);
            }
        }
    }
};
```

## Spawn Rules and Scheduling

### SpawnRule

A `SpawnRule` combines a **condition** (when to spawn) with an **amount provider** (how many):

```cpp
import helios.engine.runtime.spawn.policy.SpawnRule;
import helios.engine.runtime.spawn.policy.conditions.TimerSpawnCondition;
import helios.engine.runtime.spawn.policy.amount.FixedSpawnAmount;

auto rule = std::make_unique<SpawnRule>(
    std::make_unique<TimerSpawnCondition>(2.0f),  // Every 2 seconds
    std::make_unique<FixedSpawnAmount>(3),        // Spawn 3 entities
    SpawnRuleId{1}
);
```

### SpawnCondition

Determines **when** spawning should occur:

| Condition | Behavior |
|-----------|----------|
| `TimerSpawnCondition` | Triggers at fixed time intervals |

```cpp
class TimerSpawnCondition : public SpawnCondition {
public:
    explicit TimerSpawnCondition(float interval) : interval_(interval) {}
    
    bool isSatisfied(size_t amount, const SpawnRuleState& state,
                     GameObjectPoolSnapshot pool, const UpdateContext& ctx) const override {
        return state.sinceLastSpawn() >= interval_ 
            && pool.inactiveCount >= amount;
    }
    
    void onCommit(SpawnRuleState& state, size_t count) const override {
        state.setSinceLastSpawn(0.0f);
    }
};
```

### SpawnAmountProvider

Determines **how many** entities to spawn:

| Provider | Behavior |
|----------|----------|
| `FixedSpawnAmount` | Always returns a fixed count |
| `SpawnAmountByCallback` | Delegates to a user-provided function |

```cpp
// Dynamic amount based on game state
auto dynamicAmount = std::make_unique<SpawnAmountByCallback>(
    [](const GameObjectPoolId& poolId, const SpawnRuleState& state,
       const UpdateContext& ctx) -> size_t {
        return ctx.gameWorld().difficultyLevel() + 1;
    }
);
```

### SpawnScheduler

The `SpawnScheduler` evaluates all registered rules each frame:

```cpp
import helios.engine.runtime.spawn.scheduling.SpawnScheduler;

SpawnScheduler scheduler;

scheduler.addRule(enemyProfileId, std::move(rule));

// In GameObjectSpawnSystem::update()
scheduler.evaluate(updateContext);
auto plans = scheduler.drainScheduledPlans();

// Convert plans to commands
for (const auto& plan : plans) {
    commandBuffer.add<ScheduledSpawnPlanCommand>(std::move(plan));
}
```

## Command Pipeline Integration

### Commands

Spawn operations are represented as commands for deferred execution:

| Command | Purpose |
|---------|---------|
| `SpawnCommand` | Request to spawn entities from a profile |
| `DespawnCommand` | Request to return an entity to its pool |
| `ScheduledSpawnPlanCommand` | Execute a scheduled spawn plan |

### Dispatchers

Commands are routed to managers via typed dispatchers:

```cpp
import helios.engine.runtime.spawn.dispatcher.SpawnCommandDispatcher;
import helios.engine.runtime.spawn.dispatcher.DespawnCommandDispatcher;
import helios.engine.runtime.spawn.dispatcher.ScheduledSpawnPlanCommandDispatcher;

commandBuffer.addDispatcher<SpawnCommandDispatcher>();
commandBuffer.addDispatcher<DespawnCommandDispatcher>();
commandBuffer.addDispatcher<ScheduledSpawnPlanCommandDispatcher>();
```

### SpawnManager

The `SpawnManager` processes spawn/despawn commands:

```cpp
import helios.engine.runtime.spawn.SpawnManager;

auto spawnManager = std::make_unique<SpawnManager>();

// Register profiles
spawnManager->addSpawnProfile(enemyProfileId, std::move(enemyProfile));
spawnManager->addSpawnProfile(bulletProfileId, std::move(bulletProfile));

// Add to GameWorld
gameWorld.addManager(std::move(spawnManager));
```

## Complete Example

Here's a complete setup for an enemy spawning system:

```cpp
#include <memory>

import helios.engine.runtime.spawn;
import helios.engine.runtime.pooling.GameObjectPoolManager;
import helios.engine.mechanics.spawn.systems.GameObjectSpawnSystem;

// 1. Create pool configuration
auto poolConfig = GameObjectPoolConfig{
    .size = 50,
    .archetype = createEnemyArchetype()
};

// 2. Register pool with pool manager
auto poolManager = gameWorld.getManager<GameObjectPoolManager>();
auto enemyPoolId = poolManager->createPool(std::move(poolConfig));

// 3. Create spawn profile
auto enemyProfileId = SpawnProfileId{1};
auto enemyProfile = std::make_unique<SpawnProfile>(SpawnProfile{
    .gameObjectPoolId = enemyPoolId,
    .spawnPlacer = std::make_unique<RandomSpawnPlacer>(),
    .spawnInitializer = std::make_unique<RandomDirectionInitializer>()
});

// 4. Create spawn manager and register profile
auto spawnManager = std::make_unique<SpawnManager>();
spawnManager->addSpawnProfile(enemyProfileId, std::move(enemyProfile));
gameWorld.addManager(std::move(spawnManager));

// 5. Create spawn scheduler with rules
auto scheduler = std::make_unique<SpawnScheduler>();
scheduler->addRule(enemyProfileId, std::make_unique<SpawnRule>(
    std::make_unique<TimerSpawnCondition>(3.0f),  // Every 3 seconds
    std::make_unique<FixedSpawnAmount>(2),        // Spawn 2 enemies
    SpawnRuleId{1}
));

// 6. Add spawn system to game loop
gameLoop.phase(PhaseType::Main)
    .addPass()
    .addSystem<GameObjectSpawnSystem>(gameWorld, std::move(scheduler));

// 7. Register dispatchers
commandBuffer.addDispatcher<ScheduledSpawnPlanCommandDispatcher>();
commandBuffer.addDispatcher<DespawnCommandDispatcher>();
```

## Projectile Spawning

For projectiles (bullets, missiles), use the `EmitterContext` to spawn relative to the firing entity:

```cpp
// In ShootComponent or similar
void fire(const UpdateContext& ctx, const vec3f& position, const vec3f& direction) {
    SpawnContext spawnCtx;
    spawnCtx.emitterContext = EmitterContext{
        .position = position,
        .direction = direction,
        .velocity = direction * bulletSpeed_
    };
    
    ctx.commandBuffer().add<SpawnCommand>(bulletProfileId, spawnCtx, 1);
}
```

The `EmitterSpawnPlacer` and `EmitterInitializer` then use this context:

```cpp
auto bulletProfile = std::make_unique<SpawnProfile>(SpawnProfile{
    .gameObjectPoolId = bulletPoolId,
    .spawnPlacer = std::make_unique<EmitterSpawnPlacer>(),
    .spawnInitializer = std::make_unique<EmitterInitializer>()
});
```

## Despawning

To return entities to their pool, use `DespawnCommand`:

```cpp
// When entity should be removed (e.g., out of bounds, destroyed)
ctx.commandBuffer().add<DespawnCommand>(entity->guid(), profileId);
```

The `LevelBoundsBehaviorComponent` with `BoundsBehavior::Despawn` handles this automatically for entities leaving the level bounds.

## Module Structure

```
helios.engine.runtime.spawn/
├── SpawnManager.ixx               # Manager processing commands
├── SpawnProfile.ixx               # Profile configuration
├── SpawnContext.ixx               # Context for spawn operations
├── EmitterContext.ixx             # Emitter state for projectiles
├── SpawnCommandHandler.ixx        # Interface for command handlers
├── SpawnCommandHandlerRegistry.ixx # Registry mapping profiles to handlers
├── behavior/
│   ├── SpawnPlacer.ixx            # Placement interface
│   ├── SpawnInitializer.ixx       # Initialization interface
│   ├── placements/                # Concrete placers
│   └── initializers/              # Concrete initializers
├── policy/
│   ├── SpawnCondition.ixx         # Condition interface
│   ├── SpawnRule.ixx              # Rule combining condition + amount
│   ├── amount/                    # Amount providers
│   └── conditions/                # Concrete conditions
├── scheduling/
│   ├── SpawnScheduler.ixx         # Rule evaluation
│   ├── SpawnPlan.ixx              # Planned spawn data
│   └── ScheduledSpawnPlan.ixx     # Plan with profile ID
├── commands/                      # Spawn/Despawn commands
├── dispatcher/                    # Command dispatchers
└── events/                        # Frame events
```

## See Also

- [Component System](/docs/core-concepts/component-system) — Components used by spawned entities
- [Game Loop Architecture](/docs/core-concepts/gameloop-architecture) — How spawning integrates with phases
- [Command System](/docs/core-concepts/command-system) — Command pipeline for spawn requests
