#!/usr/bin/env node
import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const SYNC_BANNER = '<!-- Auto-synced from repository by scripts/sync-changelog.mjs. Do not edit this file directly. -->';

function buildFrontmatter(meta) {
  const { title, description, slug, tags = [], keywords = [], sidebar_label, sidebar_position } = meta;
  const escapeYAML = (value) => (/[:"'\[\]{}#&*!|>@`]/.test(value) ? `"${value.replace(/"/g, '\\"')}"` : value);
  const lines = ['---'];
  lines.push(`title: ${escapeYAML(title)}`);
  if (description) lines.push(`description: ${escapeYAML(description)}`);
  if (slug) lines.push(`slug: ${slug}`);
  if (sidebar_label) lines.push(`sidebar_label: ${escapeYAML(sidebar_label)}`);
  if (sidebar_position !== undefined) lines.push(`sidebar_position: ${sidebar_position}`);
  if (tags.length) lines.push(`tags: [${tags.join(', ')}]`);
  if (keywords.length) lines.push(`keywords: [${keywords.join(', ')}]`);
  lines.push('---');
  return lines.join('\n') + '\n\n';
}

function ensureFrontmatter(content, meta) {
  if (content.trimStart().startsWith('---')) {
    return { frontmatter: '', body: content };
  }
  const fm = buildFrontmatter(meta);
  return { frontmatter: fm, body: content.replace(/^[\n\r]+/, '') };
}

function rewriteLinksDynamic(content, sourceFile, mappings, repoRoot) {
  const routeMap = new Map();
  for (const m of mappings) {
    const srcAbs = path.resolve(m.src);
    const route = '/docs' + (m.meta.slug?.startsWith('/') ? m.meta.slug : `/${m.meta.slug || ''}`);
    routeMap.set(srcAbs, route);
  }
  const linkRegex = /(!)?\[([^\]]+)\]\(([^)]+)\)/g;
  const sourceDir = path.dirname(sourceFile);

  return content.replace(linkRegex, (full, bang, text, url) => {
    if (bang === '!' || url.startsWith('#') || /^(https?:)?\/\//i.test(url) || url.startsWith('/') || url.startsWith('mailto:')) {
      return full;
    }
    const normalized = url.replace(/\\/g, '/');
    const key = (normalized.includes('#') ? normalized.slice(0, normalized.indexOf('#')) : normalized).trim();

    // Special-case: PREREQUISITES.md should link Quick Start to website getting-started
    try {
      if (path.basename(sourceFile).toLowerCase() === 'prerequisites.md' && key === '../README.md') {
        return `[${text}](\/docs\/getting-started)`;
      }
    } catch {}

    const simpleMap = new Map([
      ['../docs/heliosapi.md', '/docs/api/overview'],
      ['./docs/heliosapi.md', '/docs/api/overview'],
      ['../../docs/heliosapi.md', '/docs/api/overview'],
      ['../docs/api/', '/docs/api'],
      ['./docs/api/', '/docs/api'],
      ['../../docs/api/', '/docs/api'],
      ['../README.md', '/'],
      ['./README.md', '/'],
      ['../../README.md', '/'],
      ['../contributing/guide', '/docs/contributing/guide'],
      ['./contributing/guide', '/docs/contributing/guide'],
      ['../../contributing/guide', '/docs/contributing/guide'],
      ['../api/overview', '/docs/api/overview'],
      ['./api/overview', '/docs/api/overview'],
      ['../../api/overview', '/docs/api/overview'],
      ['.github/workflows/tests.yml', 'https://github.com/thorstensuckow/helios/blob/main/.github/workflows/tests.yml'],
    ]);
    if (simpleMap.has(key)) {
      const target = simpleMap.get(key) + (normalized.includes('#') ? normalized.slice(normalized.indexOf('#')) : '');
      return `[${text}](${target})`;
    }

    const mdMatch = normalized.match(/([^#]+)(#.*)?$/);
    if (!mdMatch) return full;
    const pathPart = mdMatch[1];
    const hash = normalized.includes('#') ? normalized.slice(normalized.indexOf('#')) : '';

    if (/\.mdx?$/i.test(pathPart)) {
      const targetAbs = path.resolve(sourceDir, pathPart);
      const normTarget = path.normalize(targetAbs);
      if (routeMap.has(normTarget)) {
        const route = routeMap.get(normTarget);
        return `[${text}](${route}${hash})`;
      }
    }

    try {
      const targetAbs = path.resolve(sourceDir, pathPart);
      const relToRepo = path.relative(repoRoot, targetAbs).replace(/\\/g, '/');
      if (relToRepo.startsWith('examples/') && /README\.md$/i.test(relToRepo)) {
        for (const [srcPath, route] of routeMap.entries()) {
          if (srcPath.replace(/\\/g, '/').endsWith(relToRepo)) {
            return `[${text}](${route}${hash})`;
          }
        }
      }
      if (relToRepo.startsWith('docs/')) {
        const filename = relToRepo.split('/').pop();
        for (const m of mappings) {
          if (path.basename(m.src).toLowerCase() === filename.toLowerCase()) {
            const route = '/docs' + (m.meta.slug?.startsWith('/') ? m.meta.slug : `/${m.meta.slug || ''}`);
            return `[${text}](${route}${hash})`;
          }
        }
      }
    } catch {}

    return full;
  });
}

async function copyMarkdown(src, dest, repoRoot, meta, mappings) {
  let raw = await fs.readFile(src, 'utf8');
  const { frontmatter, body } = ensureFrontmatter(raw, meta);
  const rewritten = rewriteLinksDynamic(body, src, mappings, repoRoot);
  const full = frontmatter + SYNC_BANNER + '\n' + rewritten.trimEnd() + '\n';
  await fs.mkdir(path.dirname(dest), { recursive: true });
  await fs.writeFile(dest, full, 'utf8');
  console.log(`[sync-docs] ✓ ${path.relative(repoRoot, src)} → ${path.relative(repoRoot, dest)}`);
}

async function main() {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  const repoRoot = path.resolve(__dirname, '..', '..');
  const websiteRoot = path.resolve(__dirname, '..');

  const syncMappings = [
    {
      src: path.join(repoRoot, 'CHANGELOG.md'),
      dest: path.join(websiteRoot, 'docs', 'changelog.md'),
      meta: { title: 'Changelog', description: 'Chronological list of notable changes to helios; manually curated release notes.', slug: '/changelog', tags: ['changelog', 'release-notes'], keywords: ['helios', 'changelog', 'releases', 'version history'], sidebar_label: 'Changelog' }
    },
    {
      src: path.join(repoRoot, 'docs', 'styleguide.md'),
      dest: path.join(websiteRoot, 'docs', 'contributing', 'styleguide.md'),
      meta: { title: 'Code Style Guide', description: 'Coding style, modules, naming, formatting and logging conventions for helios.', slug: '/contributing/styleguide', tags: ['style', 'coding'], keywords: ['helios', 'cpp', 'styleguide', 'formatting', 'modules'], sidebar_label: 'Code Style' }
    },
    {
      src: path.join(repoRoot, 'docs', 'doxygen-style.md'),
      dest: path.join(websiteRoot, 'docs', 'contributing', 'doxygen-style.md'),
      meta: { title: 'Doxygen Style', description: 'Rules and examples for documenting public APIs using Doxygen in helios.', slug: '/contributing/doxygen-style', tags: ['docs', 'doxygen'], keywords: ['helios', 'doxygen', 'documentation style'], sidebar_label: 'Doxygen Style' }
    },
    {
      src: path.join(repoRoot, 'docs', 'CONTRIBUTING.md'),
      dest: path.join(websiteRoot, 'docs', 'contributing', 'guide.md'),
      meta: { title: 'Contributing Guide', description: 'Complete guide for contributing to helios: setup, commit conventions, pull requests, testing, and documentation.', slug: '/contributing/guide', tags: ['contributing', 'getting-started'], keywords: ['helios', 'contributing', 'pull requests', 'conventional commits', 'testing'], sidebar_label: 'Contributing Guide' }
    },
    {
      src: path.join(repoRoot, 'docs', 'CHANGELOG_GUIDE.md'),
      dest: path.join(websiteRoot, 'docs', 'contributing', 'changelog-guide.md'),
      meta: { title: 'Changelog Guide', description: 'How to maintain the helios CHANGELOG: categories, release workflow, migration notes.', slug: '/contributing/changelog-guide', tags: ['changelog', 'process'], keywords: ['helios', 'changelog maintenance', 'release process'], sidebar_label: 'Changelog Guide' }
    },
    {
      src: path.join(repoRoot, 'docs', 'issue_submission_guide.md'),
      dest: path.join(websiteRoot, 'docs', 'contributing', 'issue-submission.md'),
      meta: { title: 'Issue Submission Guide', description: 'Guidelines for submitting well-structured bug reports, feature requests, and refactoring proposals to helios.', slug: '/contributing/issue-submission', tags: ['contributing', 'issues', 'process'], keywords: ['helios', 'bug report', 'feature request', 'refactoring', 'issue submission'], sidebar_label: 'Issue Submission' }
    },
    {
      src: path.join(repoRoot, 'docs', 'testing.md'),
      dest: path.join(websiteRoot, 'docs', 'testing.md'),
      meta: { title: 'Testing', description: 'Running tests in helios: CTest usage, test patterns, debugging failures.', slug: '/testing', tags: ['testing', 'quality'], keywords: ['helios', 'testing', 'ctest', 'unit tests'], sidebar_label: 'Testing', sidebar_position: 3 }
    },
    {
      src: path.join(repoRoot, 'docs', 'PREREQUISITES.md'),
      dest: path.join(websiteRoot, 'docs', 'prerequisites.md'),
      meta: { title: 'Prerequisites', description: 'Required tools and environment for building helios: CMake 4.0+, C++23 compilers, OpenGL, platform setup.', slug: '/prerequisites', tags: ['setup', 'requirements'], keywords: ['helios', 'prerequisites', 'C++23', 'CMake', 'OpenGL'], sidebar_label: 'Prerequisites', sidebar_position: 1 }
    },
    // Core Concepts - Source of Truth for architectural patterns
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'conventions.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'conventions.md'),
      meta: { title: 'Technical Conventions', description: 'Coordinate systems (LHS), matrix storage (column-major), units (1 hu = 1 m), and mathematical foundations used in helios.', slug: '/core-concepts/conventions', tags: ['math', 'architecture'], keywords: ['helios', 'coordinate system', 'left-handed', 'matrix', 'column-major', 'conventions', 'units'], sidebar_label: 'Conventions', sidebar_position: 2 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'scene-graph.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'scene-graph.md'),
      meta: { title: 'Scene Graph', description: 'Hierarchical scene organization with transform inheritance, parent-child relationships, and camera integration.', slug: '/core-concepts/scene-graph', tags: ['scene', 'architecture'], keywords: ['helios', 'scene graph', 'transform', 'hierarchy', 'SceneNode', 'Camera'], sidebar_label: 'Scene Graph', sidebar_position: 1 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'component-system.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'component-system.md'),
      meta: { title: 'Component System', description: 'Composition-based entity design with Components, Systems, and GameWorld for flexible game logic.', slug: '/core-concepts/component-system', tags: ['gameplay', 'architecture'], keywords: ['helios', 'component', 'system', 'GameObject', 'GameWorld', 'composition'], sidebar_label: 'Component System', sidebar_position: 3 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'gameloop-architecture.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'gameloop-architecture.md'),
      meta: { title: 'Game Loop Architecture', description: 'Commands, Events, double-buffered EventBus, and ImmediateBus for decoupled game systems.', slug: '/core-concepts/gameloop-architecture', tags: ['gameplay', 'architecture'], keywords: ['helios', 'game loop', 'commands', 'events', 'EventBus', 'CommandBuffer'], sidebar_label: 'Game Loop', sidebar_position: 4 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'command-system.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'command-system.md'),
      meta: { title: 'Command System', description: 'Command pattern implementation with CommandBuffer, Dispatchers, and Manager integration for deferred action execution.', slug: '/core-concepts/command-system', tags: ['gameplay', 'architecture', 'commands'], keywords: ['helios', 'command pattern', 'CommandBuffer', 'dispatcher', 'manager', 'deferred execution'], sidebar_label: 'Command System', sidebar_position: 5 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'event-system.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'event-system.md'),
      meta: { title: 'Event System', description: 'Double-buffered event buses with phase/pass propagation for decoupled system communication.', slug: '/core-concepts/event-system', tags: ['gameplay', 'architecture', 'events'], keywords: ['helios', 'event system', 'EventBus', 'phase', 'pass', 'double-buffer', 'decoupled communication'], sidebar_label: 'Event System', sidebar_position: 6 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'spawn-system.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'spawn-system.md'),
      meta: { title: 'Spawn System', description: 'Entity lifecycle management with spawn scheduling, profiles, behaviors, and pool integration.', slug: '/core-concepts/spawn-system', tags: ['gameplay', 'architecture', 'spawn'], keywords: ['helios', 'spawn system', 'object pooling', 'entity lifecycle', 'SpawnManager', 'SpawnScheduler'], sidebar_label: 'Spawn System', sidebar_position: 7 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'object-pooling.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'object-pooling.md'),
      meta: { title: 'Object Pooling', description: 'Efficient entity lifecycle management with pre-allocated pools for frequently spawned objects.', slug: '/core-concepts/object-pooling', tags: ['gameplay', 'architecture', 'pooling'], keywords: ['helios', 'object pooling', 'GameObjectPool', 'entity recycling', 'prefab', 'acquire', 'release'], sidebar_label: 'Object Pooling', sidebar_position: 8 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'gameobject-builder.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'gameobject-builder.md'),
      meta: { title: 'GameObject Builder', description: 'Fluent builder pattern for constructing GameObjects with their associated components.', slug: '/core-concepts/gameobject-builder', tags: ['gameplay', 'architecture', 'builder'], keywords: ['helios', 'builder pattern', 'GameObjectFactory', 'fluent API', 'entity construction'], sidebar_label: 'GameObject Builder', sidebar_position: 9 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'text-rendering.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'text-rendering.md'),
      meta: { title: 'Text Rendering', description: 'GPU-accelerated text rendering with FreeType and OpenGL.', slug: '/core-concepts/text-rendering', tags: ['rendering', 'text', 'freetype'], keywords: ['helios', 'text rendering', 'FreeType', 'OpenGL', 'glyph', 'font'], sidebar_label: 'Text Rendering', sidebar_position: 10 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'sparse-set.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'sparse-set.md'),
      meta: { title: 'Sparse Set', description: 'Generic O(1) data structure for efficient entity-component storage in the ECS.', slug: '/core-concepts/sparse-set', tags: ['ecs', 'architecture', 'data-structure'], keywords: ['helios', 'sparse set', 'ECS', 'component storage', 'swap-and-pop', 'O(1)'], sidebar_label: 'Sparse Set', sidebar_position: 11 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'component-registry.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'component-registry.md'),
      meta: { title: 'Component Registry', description: 'Modular component registration system for runtime reflection, cloning, and lifecycle hooks.', slug: '/core-concepts/component-registry', tags: ['ecs', 'architecture', 'registry'], keywords: ['helios', 'component registry', 'ECS', 'reflection', 'cloning', 'lifecycle'], sidebar_label: 'Component Registry', sidebar_position: 12 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'component-lifecycle.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'component-lifecycle.md'),
      meta: { title: 'Component Lifecycle', description: 'Lifecycle hooks for ECS components: onAcquire, onRelease, onRemove, enable/disable, and cloning.', slug: '/core-concepts/component-lifecycle', tags: ['ecs', 'architecture', 'lifecycle'], keywords: ['helios', 'component lifecycle', 'ECS', 'hooks', 'pooling', 'onAcquire', 'onRelease'], sidebar_label: 'Component Lifecycle', sidebar_position: 12 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'state-management.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'state-management.md'),
      meta: { title: 'State Management', description: 'Rule-based state machines for game and match state transitions with listeners and command-driven changes.', slug: '/core-concepts/state-management', tags: ['gameplay', 'architecture', 'state'], keywords: ['helios', 'state management', 'GameState', 'MatchState', 'state machine', 'transitions'], sidebar_label: 'State Management', sidebar_position: 13 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'ecs', 'gameobject.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'ecs', 'gameobject.md'),
      meta: { title: 'GameObject', description: 'High-level entity wrapper providing type-safe component access and lifecycle management.', slug: '/core-concepts/ecs/gameobject', tags: ['ecs', 'architecture', 'entity'], keywords: ['helios', 'GameObject', 'ECS', 'entity', 'component', 'facade'], sidebar_label: 'GameObject', sidebar_position: 1 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'ecs', 'README.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'ecs', 'overview.md'),
      meta: { title: 'ECS Architecture', description: 'Entity-Component-System architecture overview for the helios game engine.', slug: '/core-concepts/ecs', tags: ['ecs', 'architecture', 'overview'], keywords: ['helios', 'ECS', 'entity', 'component', 'system', 'architecture'], sidebar_label: 'Overview', sidebar_position: 0 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'ecs', 'component-structure.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'ecs', 'component-structure.md'),
      meta: { title: 'Component Structure', description: 'Required structure for ECS components including Copy/Move constructors for the prefab system.', slug: '/core-concepts/ecs/component-structure', tags: ['ecs', 'component', 'prefab'], keywords: ['helios', 'component', 'copy constructor', 'move constructor', 'prefab', 'cloning'], sidebar_label: 'Component Structure', sidebar_position: 1 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'ecs', 'entity-manager.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'ecs', 'entity-manager.md'),
      meta: { title: 'EntityManager', description: 'Central manager for entity lifecycle and component storage in the ECS.', slug: '/core-concepts/ecs/entity-manager', tags: ['ecs', 'architecture', 'manager'], keywords: ['helios', 'EntityManager', 'ECS', 'component storage', 'SparseSet'], sidebar_label: 'EntityManager', sidebar_position: 2 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'ecs', 'entity-registry.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'ecs', 'entity-registry.md'),
      meta: { title: 'EntityRegistry', description: 'Single source of truth for entity lifecycle with versioned handles and index recycling.', slug: '/core-concepts/ecs/entity-registry', tags: ['ecs', 'architecture', 'registry'], keywords: ['helios', 'EntityRegistry', 'ECS', 'versioned handles', 'entity lifecycle'], sidebar_label: 'EntityRegistry', sidebar_position: 3 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'ecs', 'entity-handle.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'ecs', 'entity-handle.md'),
      meta: { title: 'EntityHandle', description: 'Lightweight versioned reference for safe entity identification.', slug: '/core-concepts/ecs/entity-handle', tags: ['ecs', 'architecture', 'handle'], keywords: ['helios', 'EntityHandle', 'ECS', 'versioned reference', 'stale detection'], sidebar_label: 'EntityHandle', sidebar_position: 4 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'ecs', 'view.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'ecs', 'view.md'),
      meta: { title: 'View', description: 'Lightweight iterator for querying entities with specific components.', slug: '/core-concepts/ecs/view', tags: ['ecs', 'architecture', 'query'], keywords: ['helios', 'View', 'ECS', 'component query', 'iteration'], sidebar_label: 'View', sidebar_position: 5 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'ecs', 'system.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'ecs', 'system.md'),
      meta: { title: 'System', description: 'Abstract base class for game logic processors operating on the GameWorld.', slug: '/core-concepts/ecs/system', tags: ['ecs', 'architecture', 'system'], keywords: ['helios', 'System', 'ECS', 'game logic', 'Updatable'], sidebar_label: 'System', sidebar_position: 6 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'ecs', 'updatable.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'ecs', 'updatable.md'),
      meta: { title: 'Updatable', description: 'Interface for objects requiring per-frame updates in the game loop.', slug: '/core-concepts/ecs/updatable', tags: ['ecs', 'architecture', 'interface'], keywords: ['helios', 'Updatable', 'ECS', 'update', 'game loop'], sidebar_label: 'Updatable', sidebar_position: 7 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'ecs', 'traits.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'ecs', 'traits.md'),
      meta: { title: 'Traits', description: 'Compile-time detection of component lifecycle hooks using C++20 concepts.', slug: '/core-concepts/ecs/traits', tags: ['ecs', 'architecture', 'concepts'], keywords: ['helios', 'Traits', 'ECS', 'concepts', 'compile-time', 'lifecycle'], sidebar_label: 'Traits', sidebar_position: 8 }
    },
    {
      src: path.join(repoRoot, 'docs', 'core-concepts', 'ecs', 'component-ops.md'),
      dest: path.join(websiteRoot, 'docs', 'core-concepts', 'ecs', 'component-ops.md'),
      meta: { title: 'ComponentOps', description: 'Function pointers for type-erased component lifecycle callbacks.', slug: '/core-concepts/ecs/component-ops', tags: ['ecs', 'architecture', 'reflection'], keywords: ['helios', 'ComponentOps', 'ECS', 'function pointers', 'type erasure'], sidebar_label: 'ComponentOps', sidebar_position: 9 }
    },
    {
      src: path.join(repoRoot, 'examples', 'README.md'),
      dest: path.join(websiteRoot, 'docs', 'examples', 'overview.md'),
      meta: { title: 'Examples Overview', description: 'Example applications demonstrating helios features: rendering, input, scene graph, and more.', slug: '/examples', tags: ['examples', 'tutorial'], keywords: ['helios', 'examples', 'tutorials', 'getting started'], sidebar_label: 'Overview' }
    },
    {
      src: path.join(repoRoot, 'examples', 'simple_cube_rendering', 'README.md'),
      dest: path.join(websiteRoot, 'docs', 'examples', 'simple-cube.md'),
      meta: { title: 'Simple Cube Rendering', description: 'Tutorial: Rendering a 3D cube with helios - shaders, materials, meshes, and render loop.', slug: '/examples/simple-cube', tags: ['examples', 'rendering', 'tutorial'], keywords: ['helios', '3D rendering', 'OpenGL', 'cube', 'tutorial'], sidebar_label: 'Simple Cube' }
    },
    {
      src: path.join(repoRoot, 'examples', 'game_controller_input', 'README.md'),
      dest: path.join(websiteRoot, 'docs', 'examples', 'gamepad-input.md'),
      meta: { title: 'Game Controller Input', description: 'Tutorial: Handling gamepad/controller input in helios - buttons, analog sticks, and triggers.', slug: '/examples/gamepad-input', tags: ['examples', 'input', 'tutorial'], keywords: ['helios', 'gamepad', 'controller', 'input', 'tutorial'], sidebar_label: 'Gamepad Input' }
    },
    {
      src: path.join(repoRoot, 'examples', 'spaceship_control', 'README.md'),
      dest: path.join(websiteRoot, 'docs', 'examples', 'spaceship-control.md'),
      meta: { title: 'Spaceship Control', description: 'Example: Complete game loop with command pattern, scene graph cameras, transform inheritance, and ImGui debug overlay.', slug: '/examples/spaceship-control', tags: ['examples', 'input', 'imgui', 'logging', 'game-loop', 'camera', 'scene-graph'], keywords: ['helios', 'gamepad', 'ImGui', 'logging', 'debug overlay', 'camera', 'transform inheritance', 'game system'], sidebar_label: 'Spaceship Control' }
    },
    {
      src: path.join(repoRoot, 'examples', 'spaceship_shooting', 'README.md'),
      dest: path.join(websiteRoot, 'docs', 'examples', 'spaceship-shooting.md'),
      meta: { title: 'Spaceship Shooting', description: 'Example: Twin-stick shooter with bullet pooling, shooting components, aim tracking, and arena collision.', slug: '/examples/spaceship-shooting', tags: ['examples', 'input', 'gameplay', 'bullet-pool', 'components'], keywords: ['helios', 'twin-stick', 'shooter', 'bullet pool', 'shooting', 'aiming', 'game system'], sidebar_label: 'Spaceship Shooting' }
    },
    {
      src: path.join(repoRoot, 'examples', 'enemy_spawn', 'README.md'),
      dest: path.join(websiteRoot, 'docs', 'examples', 'enemy-spawn.md'),
      meta: { title: 'Enemy Spawn', description: 'Example: Timed enemy spawning with object pooling, spawn schedulers, and random placement.', slug: '/examples/enemy-spawn', tags: ['examples', 'spawn', 'pooling', 'gameplay'], keywords: ['helios', 'spawn system', 'object pool', 'enemy', 'timer', 'random placement'], sidebar_label: 'Enemy Spawn' }
    },
    {
      src: path.join(repoRoot, 'examples', 'collision_detection', 'README.md'),
      dest: path.join(websiteRoot, 'docs', 'examples', 'collision-detection.md'),
      meta: { title: 'Collision Detection', description: 'Example: Grid-based collision detection with layers, masks, and collision events.', slug: '/examples/collision-detection', tags: ['examples', 'collision', 'physics', 'gameplay'], keywords: ['helios', 'collision detection', 'AABB', 'grid', 'spatial partitioning', 'collision events'], sidebar_label: 'Collision Detection' }
    },
    {
      src: path.join(repoRoot, 'examples', 'render_text_demo', 'README.md'),
      dest: path.join(websiteRoot, 'docs', 'examples', 'render-text-demo.md'),
      meta: { title: 'Text Rendering Demo', description: 'Example: FreeType-based text rendering with dynamic updates, font loading, and orthographic projection.', slug: '/examples/render-text-demo', tags: ['examples', 'text', 'rendering', 'freetype'], keywords: ['helios', 'text rendering', 'FreeType', 'font', 'glyph', 'OpenGL'], sidebar_label: 'Text Rendering' }
    },
    {
      src: path.join(repoRoot, 'examples', 'scoring_demo', 'README.md'),
      dest: path.join(websiteRoot, 'docs', 'examples', 'scoring-demo.md'),
      meta: { title: 'Scoring Demo', description: 'Example: Score pools, score observers, UI text rendering, and kill attribution with health/damage mechanics.', slug: '/examples/scoring-demo', tags: ['examples', 'scoring', 'ui', 'gameplay'], keywords: ['helios', 'scoring', 'score pool', 'UI', 'text rendering', 'health', 'damage'], sidebar_label: 'Scoring Demo' }
    },
  ];

  console.log('[sync-docs] Synchronizing repository documentation...');
  for (const m of syncMappings) {
    await copyMarkdown(m.src, m.dest, repoRoot, m.meta, syncMappings);
  }
  console.log('\n[sync-docs] All documentation synchronized successfully.');
}

await main().catch((err) => {
  console.error('[sync-docs] Error:', err);
  process.exit(1);
});
