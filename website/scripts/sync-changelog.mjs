#!/usr/bin/env node
import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const SYNC_BANNER = '<!-- Auto-synced from repository by scripts/sync-changelog.mjs. Do not edit this file directly. -->';

function buildFrontmatter(meta) {
  const { title, description, slug, tags = [], keywords = [], sidebar_label, sidebar_position } = meta;
  const escapeYAML = (value) => (/[:"'\[\]{}#&*!|>@`]/.test(value) ? `"${value.replace(/"/g, '\\"')}"` : value);
  const lines = ['---'];
  lines.push(`title: ${escapeYAML(title)}`);
  if (description) lines.push(`description: ${escapeYAML(description)}`);
  if (slug) lines.push(`slug: ${slug}`);
  if (sidebar_label) lines.push(`sidebar_label: ${escapeYAML(sidebar_label)}`);
  if (sidebar_position !== undefined) lines.push(`sidebar_position: ${sidebar_position}`);
  if (tags.length) lines.push(`tags: [${tags.join(', ')}]`);
  if (keywords.length) lines.push(`keywords: [${keywords.join(', ')}]`);
  lines.push('---');
  return lines.join('\n') + '\n\n';
}

function ensureFrontmatter(content, meta) {
  if (content.trimStart().startsWith('---')) {
    return { frontmatter: '', body: content };
  }
  const fm = buildFrontmatter(meta);
  return { frontmatter: fm, body: content.replace(/^[\n\r]+/, '') };
}

function rewriteLinksDynamic(content, sourceFile, mappings, repoRoot) {
  const routeMap = new Map();
  for (const m of mappings) {
    const srcAbs = path.resolve(m.src);
    const route = '/docs' + (m.meta.slug?.startsWith('/') ? m.meta.slug : `/${m.meta.slug || ''}`);
    routeMap.set(srcAbs, route);
  }
  const linkRegex = /(!)?\[([^\]]+)\]\(([^)]+)\)/g;
  const sourceDir = path.dirname(sourceFile);

  return content.replace(linkRegex, (full, bang, text, url) => {
    if (bang === '!' || url.startsWith('#') || /^(https?:)?\/\//i.test(url) || url.startsWith('/') || url.startsWith('mailto:')) {
      return full;
    }
    const normalized = url.replace(/\\/g, '/');
    const key = (normalized.includes('#') ? normalized.slice(0, normalized.indexOf('#')) : normalized).trim();
    const simpleMap = new Map([
      ['../docs/heliosapi.md', '/docs/api/overview'],
      ['./docs/heliosapi.md', '/docs/api/overview'],
      ['../../docs/heliosapi.md', '/docs/api/overview'],
      ['../docs/api/', '/docs/api'],
      ['./docs/api/', '/docs/api'],
      ['../../docs/api/', '/docs/api'],
      ['../README.md', '/'],
      ['./README.md', '/'],
      ['../../README.md', '/'],
      ['../contributing/guide', '/docs/contributing/guide'],
      ['./contributing/guide', '/docs/contributing/guide'],
      ['../../contributing/guide', '/docs/contributing/guide'],
      ['../api/overview', '/docs/api/overview'],
      ['./api/overview', '/docs/api/overview'],
      ['../../api/overview', '/docs/api/overview'],
      ['.github/workflows/tests.yml', 'https://github.com/thorstensuckow/helios/blob/main/.github/workflows/tests.yml'],
    ]);
    if (simpleMap.has(key)) {
      const target = simpleMap.get(key) + (normalized.includes('#') ? normalized.slice(normalized.indexOf('#')) : '');
      return `[${text}](${target})`;
    }

    const mdMatch = normalized.match(/([^#]+)(#.*)?$/);
    if (!mdMatch) return full;
    const pathPart = mdMatch[1];
    const hash = normalized.includes('#') ? normalized.slice(normalized.indexOf('#')) : '';

    if (/\.mdx?$/i.test(pathPart)) {
      const targetAbs = path.resolve(sourceDir, pathPart);
      const normTarget = path.normalize(targetAbs);
      if (routeMap.has(normTarget)) {
        const route = routeMap.get(normTarget);
        return `[${text}](${route}${hash})`;
      }
    }

    try {
      const targetAbs = path.resolve(sourceDir, pathPart);
      const relToRepo = path.relative(repoRoot, targetAbs).replace(/\\/g, '/');
      if (relToRepo.startsWith('examples/') && /README\.md$/i.test(relToRepo)) {
        for (const [srcPath, route] of routeMap.entries()) {
          if (srcPath.replace(/\\/g, '/').endsWith(relToRepo)) {
            return `[${text}](${route}${hash})`;
          }
        }
      }
      if (relToRepo.startsWith('docs/')) {
        const filename = relToRepo.split('/').pop();
        for (const m of mappings) {
          if (path.basename(m.src).toLowerCase() === filename.toLowerCase()) {
            const route = '/docs' + (m.meta.slug?.startsWith('/') ? m.meta.slug : `/${m.meta.slug || ''}`);
            return `[${text}](${route}${hash})`;
          }
        }
      }
    } catch {}

    return full;
  });
}

async function copyMarkdown(src, dest, repoRoot, meta, mappings) {
  let raw = await fs.readFile(src, 'utf8');
  const { frontmatter, body } = ensureFrontmatter(raw, meta);
  const rewritten = rewriteLinksDynamic(body, src, mappings, repoRoot);
  const full = frontmatter + SYNC_BANNER + '\n' + rewritten.trimEnd() + '\n';
  await fs.mkdir(path.dirname(dest), { recursive: true });
  await fs.writeFile(dest, full, 'utf8');
  console.log(`[sync-docs] ✓ ${path.relative(repoRoot, src)} → ${path.relative(repoRoot, dest)}`);
}

async function main() {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  const repoRoot = path.resolve(__dirname, '..', '..');
  const websiteRoot = path.resolve(__dirname, '..');

  const syncMappings = [
    {
      src: path.join(repoRoot, 'CHANGELOG.md'),
      dest: path.join(websiteRoot, 'docs', 'changelog.md'),
      meta: { title: 'Changelog', description: 'Chronological list of notable changes to helios; manually curated release notes.', slug: '/changelog', tags: ['changelog', 'release-notes'], keywords: ['helios', 'changelog', 'releases', 'version history'], sidebar_label: 'Changelog' }
    },
    {
      src: path.join(repoRoot, 'docs', 'styleguide.md'),
      dest: path.join(websiteRoot, 'docs', 'contributing', 'styleguide.md'),
      meta: { title: 'Code Style Guide', description: 'Coding style, modules, naming, formatting and logging conventions for helios.', slug: '/contributing/styleguide', tags: ['style', 'coding'], keywords: ['helios', 'cpp', 'styleguide', 'formatting', 'modules'], sidebar_label: 'Code Style' }
    },
    {
      src: path.join(repoRoot, 'docs', 'doxygen-style.md'),
      dest: path.join(websiteRoot, 'docs', 'contributing', 'doxygen-style.md'),
      meta: { title: 'Doxygen Style', description: 'Rules and examples for documenting public APIs using Doxygen in helios.', slug: '/contributing/doxygen-style', tags: ['docs', 'doxygen'], keywords: ['helios', 'doxygen', 'documentation style'], sidebar_label: 'Doxygen Style' }
    },
    {
      src: path.join(repoRoot, 'docs', 'CONTRIBUTING.md'),
      dest: path.join(websiteRoot, 'docs', 'contributing', 'guide.md'),
      meta: { title: 'Contributing Guide', description: 'Complete guide for contributing to helios: setup, commit conventions, pull requests, testing, and documentation.', slug: '/contributing/guide', tags: ['contributing', 'getting-started'], keywords: ['helios', 'contributing', 'pull requests', 'conventional commits', 'testing'], sidebar_label: 'Contributing Guide' }
    },
    {
      src: path.join(repoRoot, 'docs', 'CHANGELOG_GUIDE.md'),
      dest: path.join(websiteRoot, 'docs', 'contributing', 'changelog-guide.md'),
      meta: { title: 'Changelog Guide', description: 'How to maintain the helios CHANGELOG: categories, release workflow, migration notes.', slug: '/contributing/changelog-guide', tags: ['changelog', 'process'], keywords: ['helios', 'changelog maintenance', 'release process'], sidebar_label: 'Changelog Guide' }
    },
    {
      src: path.join(repoRoot, 'docs', 'issue_submission_guide.md'),
      dest: path.join(websiteRoot, 'docs', 'contributing', 'issue-submission.md'),
      meta: { title: 'Issue Submission Guide', description: 'Guidelines for submitting well-structured bug reports, feature requests, and refactoring proposals to helios.', slug: '/contributing/issue-submission', tags: ['contributing', 'issues', 'process'], keywords: ['helios', 'bug report', 'feature request', 'refactoring', 'issue submission'], sidebar_label: 'Issue Submission' }
    },
    {
      src: path.join(repoRoot, 'docs', 'testing.md'),
      dest: path.join(websiteRoot, 'docs', 'testing.md'),
      meta: { title: 'Testing', description: 'Running tests in helios: CTest usage, test patterns, debugging failures.', slug: '/testing', tags: ['testing', 'quality'], keywords: ['helios', 'testing', 'ctest', 'unit tests'], sidebar_label: 'Testing', sidebar_position: 3 }
    },
    {
      src: path.join(repoRoot, 'examples', 'README.md'),
      dest: path.join(websiteRoot, 'docs', 'examples', 'overview.md'),
      meta: { title: 'Examples Overview', description: 'Example applications demonstrating helios features: rendering, input, scene graph, and more.', slug: '/examples', tags: ['examples', 'tutorial'], keywords: ['helios', 'examples', 'tutorials', 'getting started'], sidebar_label: 'Overview' }
    },
    {
      src: path.join(repoRoot, 'examples', 'simple_cube_rendering', 'README.md'),
      dest: path.join(websiteRoot, 'docs', 'examples', 'simple-cube.md'),
      meta: { title: 'Simple Cube Rendering', description: 'Tutorial: Rendering a 3D cube with helios - shaders, materials, meshes, and render loop.', slug: '/examples/simple-cube', tags: ['examples', 'rendering', 'tutorial'], keywords: ['helios', '3D rendering', 'OpenGL', 'cube', 'tutorial'], sidebar_label: 'Simple Cube' }
    },
    {
      src: path.join(repoRoot, 'examples', 'game_controller_input', 'README.md'),
      dest: path.join(websiteRoot, 'docs', 'examples', 'gamepad-input.md'),
      meta: { title: 'Game Controller Input', description: 'Tutorial: Handling gamepad/controller input in helios - buttons, analog sticks, and triggers.', slug: '/examples/gamepad-input', tags: ['examples', 'input', 'tutorial'], keywords: ['helios', 'gamepad', 'controller', 'input', 'tutorial'], sidebar_label: 'Gamepad Input' }
    },
  ];

  console.log('[sync-docs] Synchronizing repository documentation...');
  for (const m of syncMappings) {
    await copyMarkdown(m.src, m.dest, repoRoot, m.meta, syncMappings);
  }
  console.log('\n[sync-docs] All documentation synchronized successfully.');
}

await main().catch((err) => {
  console.error('[sync-docs] Error:', err);
  process.exit(1);
});
